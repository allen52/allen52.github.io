<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Steve&#39;s Blog</title>
  
  <subtitle>写写生活技术观点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://allen52.top/"/>
  <updated>2020-08-09T08:52:01.649Z</updated>
  <id>https://allen52.top/</id>
  
  <author>
    <name>Steve</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ template ReadingNote-Chapter6</title>
    <link href="https://allen52.top/2020/08/09/C++%20template%20Reading%20Note-Chapter6/"/>
    <id>https://allen52.top/2020/08/09/C++%20template%20Reading%20Note-Chapter6/</id>
    <published>2020-08-09T08:51:59.000Z</published>
    <updated>2020-08-09T08:52:01.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动语义和enable-if-lt-gt"><a href="#移动语义和enable-if-lt-gt" class="headerlink" title="移动语义和enable_if&lt;&gt;"></a>移动语义和enable_if&lt;&gt;</h1><p>移动语义(move semantics)是 C++11 引入的一个重要特性。在 copy 或者赋值的时候，可以 通过它将源对象中的内部资源 move(“steal”)到目标对象，而不是 copy 这些内容。当然 这样做的前提是源对象不在需要这些内部资源或者状态(因为源对象将会被丢弃)</p><p>关于移动语义的解释可以参考这篇文章：<a href="https://blog.csdn.net/p942005405/article/details/84644069" target="_blank" rel="noopener">https://blog.csdn.net/p942005405/article/details/84644069</a><br>实际std::move在做什么可以参考这篇文章：<a href="https://blog.csdn.net/iMatt/article/details/83834794" target="_blank" rel="noopener">https://blog.csdn.net/iMatt/article/details/83834794</a><br>而为什么要这么做，可以参考逼乎的回答：<a href="https://www.zhihu.com/question/50652989" target="_blank" rel="noopener">https://www.zhihu.com/question/50652989</a></p><p>移动语义对模板的设计有重要影响，在泛型代码中也引入了一些特殊的规则来支持移动语义</p><h3 id="完美转发-Perfect-Forwarding"><a href="#完美转发-Perfect-Forwarding" class="headerlink" title="完美转发(Perfect Forwarding)"></a>完美转发(Perfect Forwarding)</h3><p>假设希望实现的泛型代码可以将被传递参数的基本特性转发出去:</p><blockquote><p>可变对象被转发之后依然可变。<br>Const对象被转发之后依然是const的。<br>可移动对象(可以从中窃取资源的对象)被转发之后依然是可移动的。</p></blockquote><p>不使用模板的话，为达到这一目的就需要对以上三种情况分别编程。比如为了将调用 f()时 传递的参数转发给函数 g():</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for variable\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X <span class="keyword">const</span>&amp;)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for constant\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;&amp;)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for move object\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X&amp; val)</span> </span>&#123;</span><br><span class="line">g(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X <span class="keyword">const</span>&amp; val)</span> </span>&#123;</span><br><span class="line">g(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">g(<span class="built_in">std</span>::move(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X v;</span><br><span class="line">X <span class="keyword">const</span> c;</span><br><span class="line">f(v);<span class="comment">// f() for nonconstant object calls f(X&amp;) =&gt; calls g(X&amp;)</span></span><br><span class="line">f(c);<span class="comment">// f() for constant object calls f(X const&amp;) =&gt; calls g(X const&amp;)</span></span><br><span class="line">f(X());<span class="comment">// f() for temporary calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;)</span></span><br><span class="line">f(<span class="built_in">std</span>::move(v));<span class="comment">// f() for movable variable calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中针对可移动对象(一个右值引用)的代码不同于其它两组代码;它需要用 std::move() 来处理其参数，因为参数的移动语义不会被一起传递。</p><p>虽然第三个 f()中的 val 被声明成右值 引用，但是当其在 f()内部被使用时，它依然是一个非常量左值(参考附录 B)，其行为也将 和第一个 f()中的情况一样。因此如果不使用 std::move()的话，在第三个 f()中调用的将是 g(X&amp;) 而不是 g(X&amp;&amp;)。</p><p>如果试图在泛型代码中统一以上三种情况，会遇到这样一个问题:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    g(val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个模板只对前两种情况有效，对第三种用于可移动对象的情况无效.</p><p>基于这一原因，C++11 引入了特殊的规则对参数进行完美转发(perfect forwarding)。实现 这一目的的惯用方法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    g(<span class="built_in">std</span>::forward&lt;T&gt;(val)); <span class="comment">// perfect forward val to g()     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 std::move 没有模板参数，并且会无条件地移动其参数;<br>而 std::forward&lt;&gt;会跟据被传递 参数的具体情况决定是否“转发”其潜在的移动语义。</p><p>不要以为模板参数 T 的 T&amp;&amp;和具体类型 X 的 X&amp;&amp;是一样的。虽然语法上看上去类似，但是 它们适用于不同的规则:</p><blockquote><p>具体类型X的X&amp;&amp;声明了一个右值引用参数。只能被绑定到一个可移动对象上(一个prvalue，比如临时对象，一个 xvalue，比如通过 std::move()传递的参数，更多细节参见附录 B)。它的值总是可变的，而且总是可以被“窃取”。</p><p>模板参数T的T&amp;&amp;声明了一个转发引用(亦称万能引用)。可以被绑定到可变、不可变(比如 const)或者可移动对象上。在函数内部这个参数也可以是可变、不可变或者 指向一个可以被窃取内部数据的值。</p></blockquote><p>一个可以完美转发其参数的程序会像下面这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for variable\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X <span class="keyword">const</span>&amp;)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for constant\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;&amp;)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for move object\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">g(<span class="built_in">std</span>::forward&lt;T&gt;(val));<span class="comment">// call the right g() for any passed argument val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊成员函数模板"><a href="#特殊成员函数模板" class="headerlink" title="特殊成员函数模板"></a>特殊成员函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// generic constructor for passed initial name:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span> : <span class="title">name</span><span class="params">(<span class="built_in">std</span>::forward&lt;STR&gt;(n))</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TMPL-CONSTR for ’"</span> &lt;&lt; name &lt;&lt; <span class="string">"’\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy and move constructor:</span></span><br><span class="line">    Person (Person <span class="keyword">const</span>&amp; p) : name(p.name) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"COPY-CONSTRPerson’"</span>&lt;&lt;name&lt;&lt;<span class="string">"’\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person (Person&amp;&amp; p) : name(<span class="built_in">std</span>::move(p.name)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MOVE-CONSTR Person ’"</span> &lt;&lt; name &lt;&lt; <span class="string">"’\n"</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当试图调用拷贝构造函数的时候，会遇到错误:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure><p>而用一个可移动对象初始化 Person 的话却可以正常工作:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="built_in">std</span>::move(p1))</span></span>; <span class="comment">// OK: move Person =&gt; calls MOVECONST</span></span><br></pre></td></tr></table></figure><p>根据 C++重载解析规则(参见 16.2.5 节)，对于一个非 const 左值的 Person p， 成员模板通常比预定义的拷贝构造函数更匹配:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt; </span><br><span class="line">Person(STR&amp;&amp; n)</span><br></pre></td></tr></table></figure><p>这里 STR 可以直接被替换成 Person&amp;，但是对拷贝构造函数还要做一步 const 转换。</p><p>额外提供一个非 const 的拷贝构造函数看上去是个不错的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person (Person&amp; p)</span><br></pre></td></tr></table></figure><p>不过这只是一个部分解决问题的方法，更好的办法依然是使用模板。我们真正想做的是当参 数是一个 Person 对象或者一个可以转换成 Person 对象的表达式时，不要启用模板。</p><p>这可以通过 std::enable_if&lt;&gt;实现，它也正是下一节要讲的内容。</p><h3 id="通过-std-enable-if-lt-gt-禁用模板"><a href="#通过-std-enable-if-lt-gt-禁用模板" class="headerlink" title="通过 std::enable_if&lt;&gt;禁用模板"></a>通过 std::enable_if&lt;&gt;禁用模板</h3><p>从 C++11 开始，通过 C++标准库提供的辅助模板 std::enable_if&lt;&gt;，可以在某些编译期条件下 忽略掉函数模板。</p><p>比如，如果函数模板 foo&lt;&gt;的定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;(<span class="keyword">sizeof</span>(T) &gt; <span class="number">4</span>)&gt;::type </span><br><span class="line">foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一模板定义会在 sizeof(T) &gt; 4 不成立的时候被忽略掉，如果 sizeof<T> &gt; 4 成立，函数模板 会展开成:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::enable_if&lt;&gt;是一种类型萃取(type trait)，它会根据一个作为其(第一个)模 板参数的编译期表达式决定其行为:</p><blockquote><p>如果这个表达式结果为true，它的type成员会返回一个类型:<br>    – 如果没有第二个模板参数，返回类型是 void。<br>    – 否则，返回类型是其第二个参数的类型。</p><p>如果表达式结果 false，则其成员类型是未定义的。根据模板的一个叫做 SFINAE的规则， 这会导致包含 std::enable_if&lt;&gt;表达式的函数模板被忽略掉。</p></blockquote><p>由于将 enable_if 表达式放在声明的中间不是一个明智的做法，因此使用 std::enable_if&lt;&gt; 的更常见的方法是使用一个额外的、有默认值的模板参数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;(<span class="keyword">sizeof</span>(T) &gt; <span class="number">4</span>)&gt;&gt; </span><br><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 sizeof(T) &gt; 4，它会被展开成:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-enable-if-lt-gt"><a href="#使用-enable-if-lt-gt" class="headerlink" title="使用 enable_if&lt;&gt;"></a>使用 enable_if&lt;&gt;</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = </span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_convertible_v&lt;STR, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;&gt; </span><br><span class="line">Person(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure><p>如果 STR 可以转换成 std::string，这个定义会扩展成:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line">Person(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure><p>这里同样可以使用别名模板给限制条件定义一个别名:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString = </span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_convertible_v&lt;T,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt; </span><br><span class="line">Person(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure><p>现在完整 Person 类如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_convertible&lt;T,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::value&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//generic constuctor for passed initial name:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt;</span><br><span class="line"><span class="keyword">explicit</span> Person(STR&amp;&amp; n)</span><br><span class="line">: name(<span class="built_in">std</span>::forward&lt;STR&gt;(n)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"TMPL-CONSTR for "</span> &lt;&lt; name&lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copy and move constructor:</span></span><br><span class="line">Person (Person <span class="keyword">const</span>&amp; p) : name(p.name) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"COPY-CONSTR Person "</span> &lt;&lt;name&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person(Person&amp;&amp; p) : name(<span class="built_in">std</span>::move(p.name)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"MOVE-CONSTR Person "</span>&lt;&lt;name&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-concept-简化-enable-if-lt-gt-表达式"><a href="#使用-concept-简化-enable-if-lt-gt-表达式" class="headerlink" title="使用 concept 简化 enable_if&lt;&gt;表达式"></a>使用 concept 简化 enable_if&lt;&gt;表达式</h3><p>即使使用了模板别名，enable_if 的语法依然显得很蠢，因为它使用了一个变通方法:为了达 到目的，使用了一个额外的模板参数，并且通过“滥用”这个参数对模板的使用做了限制。 这样的代码不容易读懂，也使模板中剩余的代码不易理解。<br>原则上我们所需要的只是一个能够对函数施加限制的语言特性，当这一限制不被满足的时 候，函数会被忽略掉。</p><p>这个语言特性就是人们期盼已久的 concept，可以通过其简单的语法对函数模板施加限制条 件。不幸的是，虽然已经讨论了很久，但是 concept 依然没有被纳入 C++17 标准。一些编译 器目前对 concept 提供了试验性的支持，不过其很有可能在 C++17 之后的标准中得到支持(目 前确定将在 C++20 中得到支持)。</p><p>通过使用 concept 可以写出下面这样的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="built_in">std</span>::is_convertible_v&lt;STR,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">Person(STR&amp;&amp; n) : name(<span class="built_in">std</span>::forward&lt;STR&gt;(n)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>在模板中，可以通过使用“转发引用”(亦称“万能引用”，声明方式为模板参数T 加&amp;&amp;)和 std::forward&lt;&gt;将模板调用参完美地数转发出去。</p><p>将完美转发用于成员函数模板时，在copy或者move对象的时候它们可能比预定义的 特殊成员函数更匹配。</p><p>可以通过使用std::enable_if&lt;&gt;并在其条件为false的时候禁用模板。</p><p>通过使用std::enable_if&lt;&gt;，可以避免一些由于构造函数模板或者赋值构造函数模板比隐<br>式产生的特殊构造函数更加匹配而带来的问题。</p><p>可以通过删除对 const volatile 类型参数预定义的特殊成员函数，并结合使用<br>std::enable_if&lt;&gt;，将特殊成员函数模板化。</p><p>通过concept可以使用更直观的语法对函数模板施加限制。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动语义和enable-if-lt-gt&quot;&gt;&lt;a href=&quot;#移动语义和enable-if-lt-gt&quot; class=&quot;headerlink&quot; title=&quot;移动语义和enable_if&amp;lt;&amp;gt;&quot;&gt;&lt;/a&gt;移动语义和enable_if&amp;lt;&amp;gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="C++" scheme="https://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter5</title>
    <link href="https://allen52.top/2020/07/21/C++%20template%20Reading%20Note-Chapter5/"/>
    <id>https://allen52.top/2020/07/21/C++%20template%20Reading%20Note-Chapter5/</id>
    <published>2020-07-21T11:59:59.000Z</published>
    <updated>2020-07-21T16:03:56.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h1><p>本章将涉及一些和模板实际使用有关的晋级知识，包含：关键字 typename 的使用，定义为 模板的成员函数以及嵌套类，模板参数模板（template template parameters），零初始化以 及其它一些关于使用字符串常量作为模板参数的细节讨论。这些内容有时会比较复杂，但是 作为一个 C++的日常使用者，应该至少已经听说过它们了</p><h4 id="typename关键字"><a href="#typename关键字" class="headerlink" title="typename关键字"></a>typename关键字</h4><p>关键字 typename 在 C++标准化过程中被引入进来，用来澄清模板内部的一个标识符代表的 是某种类型，而不是数据成员<br>通常而言，当一个依赖于模板参数的名称代表的是某种类型的时候，就必须使用 typename。</p><p>使用 typename 的一种场景是用来声明泛型代码中标准容器的迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// print elements of an STL container template&lt;typename T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printcoll</span> <span class="params">(T <span class="keyword">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::const_iterator pos; <span class="comment">// iterator to iterate over coll </span></span><br><span class="line">    <span class="function"><span class="keyword">typename</span> T::const_iterator <span class="title">end</span><span class="params">(coll.end())</span></span>; <span class="comment">// end position</span></span><br><span class="line">    <span class="keyword">for</span> (pos=coll.begin(); pos!=end; ++pos) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*pos&lt;&lt;’’;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ’\n’; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数模板中，调用参数是一个类型为 T 的标准容器。为了遍历容器中的所有元素，使 用了声明于每个标准容器中的迭代器类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stlcontainer</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = ...; <span class="comment">// iterator for read/write access </span></span><br><span class="line">    <span class="keyword">using</span> const_iterator = ...; <span class="comment">// iterator for read access ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此为了使用模板类型 T 的 cons_iterator，必须在其前面使用 typename:</p><h4 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h4><p>对于基础类型，比如 int，double 以及指针类型，由于它们没有默认构造函数，因此它们不 会被默认初始化成一个有意义的值。比如任何未被初始化的局部变量的值都是未定义的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// x has undefined value</span></span><br><span class="line">    <span class="keyword">int</span>* ptr; <span class="comment">// ptr points to anywhere (instead of nowhere) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在定义模板时，如果想让一个模板类型的变量被初始化成一个默认值，那么只是简单的 定义是不够的，因为对内置类型，它们不会被初始化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x; <span class="comment">// x has undefined value if T is built-in type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好显式的调用其默认构造函数来将它们初始化成 0(对于 bool 类型，初始化为 false，对于指针类型，初始化成 nullptr)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x&#123;&#125;; <span class="comment">// x is zero (or false) if T is a built-in type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种初始化的方法被称为“值初始化(value initialization)”，它要么调用一个对象已有的 构造函数，要么就用零来初始化这个对象。即使它有显式的构造函数也是这样<br>在 C++11 之前，确保一个对象得到显示初始化的方式是:</p><blockquote><p>T x = T(); // x is zero (or false) if T is a built-in type</p></blockquote><p>为确保类模板中类型被参数化了的成员得到适当的初始化，可以定义一个默认的构造函数并 在其中对相应成员做初始化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        T x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass() : x&#123;&#125; &#123; <span class="comment">// ensures that x is initialized even for</span></span><br><span class="line">        <span class="comment">//built-in types</span></span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用this-gt"><a href="#使用this-gt" class="headerlink" title="使用this-&gt;"></a>使用this-&gt;</h4><p>对于类模板，如果它的基类也是依赖于模板参数的，那么对它而言即使x是继承而来的，使用this-&gt;x和x也不一定是等效的。比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            bar(); <span class="comment">// calls external bar() or error </span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Derived 中的 bar()永远不会被解析成Base中的bar()。因此这样做要么会遇到错误，要么就是调用了其它地方的bar()(比如可能是定义在其它地方的global的bar())，目前作为经验法则，建议当使用定义于基类中的、依赖于模板参数的成员时，用this-&gt;或者 Base<T>::来修饰它</p><h4 id="使用裸数组或者字符串常量的模板"><a href="#使用裸数组或者字符串常量的模板" class="headerlink" title="使用裸数组或者字符串常量的模板"></a>使用裸数组或者字符串常量的模板</h4><p>需要格外注意以下内容:<br>第一，如果参数是按引用传递的，那么参数类型不会退化(decay)。也就是说当传递”hello” 作为参数时，模板类型会被推断为 char const[6]。这样当向模板传递长度不同的裸数组或者 字符串常量时就可能遇到问题，因为它们对应的模板类型不一样。只有当按值传递参数时， 模板类型才会退化(decay)，这样字符串常量会被推断为 char const* 。<br>不过也可以像下面这样定义专门用来处理裸数组或者字符串常量的模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N, <span class="keyword">int</span> M&gt; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less</span> <span class="params">(T(&amp;a)[N], T(&amp;b)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N &amp;&amp; i&lt;M; ++i)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&lt;a[i]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N &lt; M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当像下面这样使用该模板的时候:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; less(x,y) &lt;&lt; ’\n’;</span><br></pre></td></tr></table></figure><p>less&lt;&gt;中的 T 会被实例化成 int，N 被实例化成 3，M 被实例化成 5。</p><p>请注意你可以、某些情况下可能也必须去为边界未知的数组做重载或者部分特化。下面的代 码展示了对数组所做的所有可能的重载:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>;</span> <span class="comment">// 主模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> SZ&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T[SZ]&gt; // <span class="title">partial</span> <span class="title">specialization</span> <span class="title">for</span> <span class="title">arrays</span> <span class="title">of</span> <span class="title">known</span> <span class="title">bounds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"print() for T["</span> &lt;&lt; SZ &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> SZ&gt;</span><br><span class="line">structMyClass&lt;T(&amp;)[SZ]&gt; <span class="comment">//partialspec.forreferencestoarraysof known bounds</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"print() for T(&amp;)["</span> &lt;&lt; SZ &lt;&lt;<span class="string">"]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T[]&gt; // <span class="title">partial</span> <span class="title">specialization</span> <span class="title">for</span> <span class="title">arrays</span> <span class="title">of</span> <span class="title">unknown</span> <span class="title">bounds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"print()forT[]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T(&amp;)[]&gt; // <span class="title">partial</span> <span class="title">spec</span>. <span class="title">for</span> <span class="title">references</span> <span class="title">to</span> <span class="title">arrays</span> <span class="title">of</span> <span class="title">unknown</span> <span class="title">bounds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"print()forT(&amp;)[]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T*&gt; // <span class="title">partial</span> <span class="title">specialization</span> <span class="title">for</span> <span class="title">pointers</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"print()forT*\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码针对以下类型对 MyClass&lt;&gt;做了特化:边界已知和未知的数组，边界已知和未知 的数组的引用，以及指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"arrays.hpp"</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1[<span class="number">7</span>], <span class="keyword">int</span> a2[], <span class="comment">// pointers by language rules</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> (&amp;a3)[<span class="number">42</span>], <span class="comment">// reference to array of known bound </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> (&amp;x0)[], <span class="comment">// reference to array of unknown bound </span></span></span></span><br><span class="line"><span class="function"><span class="params">    T1 x1, <span class="comment">// passing by value decays</span></span></span></span><br><span class="line"><span class="function"><span class="params">    T2&amp; x2, T3&amp;&amp; x3)</span> <span class="comment">// passing by reference &#123;</span></span></span><br><span class="line"><span class="function">        MyClass&lt;<span class="title">decltype</span><span class="params">(a1)</span>&gt;::<span class="title">print</span><span class="params">()</span></span>; <span class="comment">// uses MyClass&lt;T*&gt;</span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(a2)&gt;::print(); <span class="comment">// uses MyClass&lt;T*&gt; a1, a2 退化成 指针 因为语言特性</span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(a3)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[SZ]&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x0)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x1)&gt;::print(); <span class="comment">// uses MyClass&lt;T*&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x2)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x3)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt; // 万能引用，引用折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">42</span>];</span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(a)&gt;::print(); <span class="comment">// uses MyClass&lt;T[SZ]&gt; </span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> x[]; <span class="comment">// forward declare array </span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(x)&gt;::print(); <span class="comment">// uses MyClass&lt;T[]&gt; </span></span><br><span class="line">    foo(a, a, a, x, x, x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">15</span>&#125;; <span class="comment">// define forward-declared array</span></span><br></pre></td></tr></table></figure><h4 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h4><p>通常只有当两个 stack 类型相同的时候才可以相互赋值(stack 的类型相同说明它们的元素类型也相同)。即使两个 stack 的元素类型之间可以隐式转换， 也不能相互赋值:<br>默认的赋值运算符要求等号两边的对象类型必须相同，因此如果两个 stack 之间的元素类型 不同的话，这一条件将得不到满足。<br>但是，只要将赋值运算符定义成模板，就可以将两个元素类型可以做转换的 stack 相互赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp;); &#125;;</span><br></pre></td></tr></table></figure><p>以上代码中有如下两点改动:</p><ol><li>赋值运算符的参数是一个元素类型为 T2 的 stack。</li><li>新的模板使用 std::deque&lt;&gt;作为内部容器。这是为了方便新的赋值运算符的定义。</li></ol><p>新的赋值运算符被定义成下面这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp; op2) </span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;T2&gt; tmp(op2); <span class="comment">// create a copy of the assigned stack </span></span><br><span class="line">    elems.clear(); <span class="comment">// remove existing elements</span></span><br><span class="line">    <span class="keyword">while</span> (!tmp.empty()) &#123; <span class="comment">// copy all elements</span></span><br><span class="line">        elems.push_front(tmp.top());</span><br><span class="line">        tmp.pop();</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现多了一次拷贝，可以用另一种实现方式，为了访问 op2 的私有成员，可以将其它所有类型的 stack 模板的实例都定义成友元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Void <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">        Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line">        <span class="comment">// to get access to private members of Stack&lt;T2&gt; for any type T2:</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如你所见，由于模板参数的名字不会被用到，因此可以被省略掉:</p><blockquote><p>template<typename> friend class Stack;</p></blockquote><p>这样就就可以将赋值运算符定义成如下形式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp; op2) </span><br><span class="line">&#123;</span><br><span class="line">    elems.clear(); <span class="comment">// remove existing elements </span></span><br><span class="line">    elems.insert(elems.begin(), <span class="comment">// insert at the beginning </span></span><br><span class="line">        op2.elems.begin(), <span class="comment">// all elements from op2 </span></span><br><span class="line">        op2.elems.end());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的赋值就不会改变 floatStack 的类型，也不会改变它的元素的类型。在赋值之后， floatStack 存储的元素依然是 float 类型，top()返回的值也依然是 float 类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">int</span>&gt; intStack; <span class="comment">// stack for ints</span></span><br><span class="line">Stack&lt;<span class="keyword">float</span>&gt; floatStack; <span class="comment">// stack for floats</span></span><br><span class="line">...</span><br><span class="line">floatStack = intStack; <span class="comment">// OK: stacks have different types, </span></span><br><span class="line"><span class="comment">// but int converts to float</span></span><br></pre></td></tr></table></figure><p>看上去这个赋值运算符模板不会进行类型检查，必要的类型检查会在将源 stack(上文中的 op2 或者其备 份 temp)中的元素插入到目标 stack 中的时候进行:</p><blockquote><p>elems.push_front(tmp.top());</p></blockquote><p>比如如果将存储 string 的 stack 赋值给存储 int 的 stack，那么在编译这一行代码的时候会遇 到如下错误信息:不能将通过 tmp.top()返回的 string 用作 elems.push_front()的参数。</p><h5 id="成员模板的特例化"><a href="#成员模板的特例化" class="headerlink" title="成员模板的特例化"></a>成员模板的特例化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoolString</span> &#123;</span> </span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> value; </span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        BoolString (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span><br><span class="line">        : value(s) &#123;&#125;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">        T get() <span class="keyword">const</span> &#123; <span class="comment">// get value (converted to T)</span></span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以像下面这样对其成员函数模板 get()进行全特例化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// full specialization for BoolString::getValue&lt;&gt;() for bool template&lt;&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> BoolString::get&lt;<span class="keyword">bool</span>&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="string">"true"</span> || value == <span class="string">"1"</span> || value == <span class="string">"on"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以像下面这样使用这个 class 以及它的全特例化版本:</p><blockquote><p>std::cout &lt;&lt; std::boolalpha;<br>BoolString s1(“hello”);<br>std::cout &lt;&lt; s1.get() &lt;&lt; ’\n’; //prints hello std::cout &lt;&lt; s1.get<bool>() &lt;&lt; ’\n’; //prints false BoolString s2(“on”);<br>std::cout &lt;&lt; s2.get<bool>() &lt;&lt; ’\n’; //prints true</p></blockquote><h5 id="泛型-lambdas-和成员模板"><a href="#泛型-lambdas-和成员模板" class="headerlink" title="泛型 lambdas 和成员模板"></a>泛型 lambdas 和成员模板</h5><p>在 C++14 中引入的泛型 lambdas，是一种成员模板的简化。对于一个简单的计算两个任意类 型参数之和的 lambda:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会默认为它构造下面这样一个类:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCompilerSpecificName</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SomeCompilerSpecificName(); <span class="comment">// constructor only callable by compiler</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T1 x, T2 y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="模板参数模板"><a href="#模板参数模板" class="headerlink" title="模板参数模板"></a>模板参数模板</h5><p>如果允许模板参数也是一个类模板的话，会有不少好处。在这里依然使用 Stack 类模板作为例子</p><p>对 5.5 节中的 stack 模板，如果不想使用默认的内部容器类型 std::deque，那么就需要两次指 定 stack 元素的类型。也就是说为了指定内部容器的类型，必须同时指出容器的类型和元素 的类型:</p><blockquote><p>Stack&lt;int, std::vector<int>&gt; vStack; // integer stack that uses a vector</p></blockquote><p>使用模板参数模板，在声明 Stack 类模板的时候就可以只指定容器的类型而不去指定容器中 元素的类型:</p><blockquote><p>Stack&lt;int, std::vector&gt; vStack; // integer stack that uses a vector</p></blockquote><p>为此就需要在 Stack 的定义中将第二个模板参数声明为模板参数模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="class"><span class="keyword">class</span> <span class="title">Cont</span> = <span class="title">std</span>:</span>:<span class="built_in">deque</span>&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                Cont&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">                <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">                <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">                    <span class="keyword">return</span> elems.empty(); </span><br><span class="line">                &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区别在于第二个模板参数被定义为一个类模板:</p><blockquote><p>template<typename Elem> class Cont</p></blockquote><p>默认类型也从 std::deque<T>变成 std::deque，用第一个模板参数实例化第二个模板参数的情况是由 Stack 自身的情况决定的。实际上，可以在类模板内部用任意类型实例化一个模板参数模板。</p><p>从 C++11 开始，也可以用别名模板(alias template)取代 Cont，但是直到 C++17，在声明模 板参数模板时才可以用 typename 代替 class，我是觉得用typename比较好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="keyword">typename</span> Cont = <span class="built_in">std</span>::<span class="built_in">deque</span>&gt;</span><br><span class="line">class Stack &#123; <span class="comment">//ERROR before C++17</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="模板参数模板的参数匹配"><a href="#模板参数模板的参数匹配" class="headerlink" title="模板参数模板的参数匹配"></a>模板参数模板的参数匹配</h5><p>如果你尝试使用新版本的 Stack，可能会遇到错误说默认的 std::deque 和模板参数模板 Cont 不匹配。这是因为在 C++17 之前，template<typename Elem> typename Cont = std::deque 中 的模板参数必须和实际参数(std::deque)的模板参数匹配(对变参模板有些例外，见 12.3.4 节)。而且实际参数(std::deque 有两个参数，第二个是默认参数 allocator)的默认参数也 要被匹配，这样 template<typename Elem> typename Cont = std::dequ 就不满足以上要求(不 过对 C++17 可以)</p><p>作为变通，可以将类模板定义成下面这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem,</span><br><span class="line">        <span class="keyword">typename</span> Alloc = <span class="built_in">std</span>::allocator&lt;Elem&gt;&gt; class Cont = <span class="built_in">std</span>::<span class="built_in">deque</span>&gt; </span><br><span class="line">class Stack &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Cont&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>为了使用依赖于模板参数的类型名称，需要用typename修饰该名称。</p></blockquote><blockquote><p>为了访问依赖于模板参数的父类中的成员，需要用this-&gt;或者类名修饰该成员。</p></blockquote><blockquote><p>嵌套类或者成员函数也可以是模板。一种应用场景是实现可以进行内部类型转换的泛型<br>代码。</p></blockquote><blockquote><p>模板化的构造函数或者赋值运算符不会取代预定义的构造函数和赋值运算符。</p></blockquote><blockquote><p>使用花括号初始化或者显式地调用默认构造函数，可以保证变量或者成员模板即使被内置类型实例化，也可以被初始化成默认值。</p></blockquote><blockquote><p>可以为裸数组提供专门的特化模板，它也可以被用于字符串常量。</p></blockquote><blockquote><p>只有在裸数组和字符串常量不是被按引用传递的时候，参数类型推断才会退化。(裸数组退化成指针)</p></blockquote><blockquote><p>可以定义变量模板(从C++14开始)。</p></blockquote><blockquote><p>模板参数也可以是类模板，称为模板参数模板(template template parameters)。</p></blockquote><blockquote><p>模板参数模板的参数类型必须得到严格匹配。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础技巧&quot;&gt;&lt;a href=&quot;#基础技巧&quot; class=&quot;headerlink&quot; title=&quot;基础技巧&quot;&gt;&lt;/a&gt;基础技巧&lt;/h1&gt;&lt;p&gt;本章将涉及一些和模板实际使用有关的晋级知识，包含：关键字 typename 的使用，定义为 模板的成员函数以及嵌套类，模板参
      
    
    </summary>
    
    
    
      <category term="C++" scheme="https://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>读google HDR+ spaper</title>
    <link href="https://allen52.top/2020/07/19/%E8%AF%BBgoogle-HDR-spaper/"/>
    <id>https://allen52.top/2020/07/19/%E8%AF%BBgoogle-HDR-spaper/</id>
    <published>2020-07-19T12:36:37.000Z</published>
    <updated>2020-07-19T12:42:10.119Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-关于ZSL的Flow-为什么谷歌相机和华为的能秒拍？"><a href="#1-关于ZSL的Flow-为什么谷歌相机和华为的能秒拍？" class="headerlink" title="1.关于ZSL的Flow 为什么谷歌相机和华为的能秒拍？"></a>1.关于ZSL的Flow 为什么谷歌相机和华为的能秒拍？</h5><p>framewrok层和APP到底做了什么看一下代码</p><h5 id="2-谷歌在3lux以上用HDR-3lux到0-3lux用Night-Sight"><a href="#2-谷歌在3lux以上用HDR-3lux到0-3lux用Night-Sight" class="headerlink" title="2.谷歌在3lux以上用HDR+ 3lux到0.3lux用Night Sight"></a>2.谷歌在3lux以上用HDR+ 3lux到0.3lux用Night Sight</h5><p>Smartphone cameras that take a single picture begin to struggle at 30 lux. Phones that capture and merge several pictures (as HDR+ does) can do well down to 3 lux, but in dimmer scenes don’t perform well (more on that below), relying on using their flash. With Night Sight, our goal was to improve picture-taking in the regime between 3 lux and 0.3 lux, using a smartphone, a single shutter press, and no LED flash. To make this feature work well includes several key elements, the most important of which is to capture more photons.</p><h5 id="4-HDR-是用ZSL的buffer-结合HDR-的论文看，HDR-采用的自己的一套曝光策略："><a href="#4-HDR-是用ZSL的buffer-结合HDR-的论文看，HDR-采用的自己的一套曝光策略：" class="headerlink" title="4.HDR+是用ZSL的buffer 结合HDR+的论文看，HDR+采用的自己的一套曝光策略："></a>4.HDR+是用ZSL的buffer 结合HDR+的论文看，HDR+采用的自己的一套曝光策略：</h5><p>HDR+ limits exposures to at most 66ms no matter how dim the scene is, allowing our viewfinder to keep up a display rate of at least 15 frames per second.</p><p>When you press the shutter button, the camera sends the most recent 9 or 15 frames to our HDR+ or Super Res Zoom software.</p><h5 id="5-谷歌怎么做防抖-用光流做运动估计"><a href="#5-谷歌怎么做防抖-用光流做运动估计" class="headerlink" title="5.谷歌怎么做防抖 用光流做运动估计"></a>5.谷歌怎么做防抖 用光流做运动估计</h5><p>To combat motion blur that OIS can’t fix, the Pixel 3’s default picture-taking mode uses “motion metering”, which consists of using optical flow to measure recent scene motion and choosing an exposure time that minimizes this blur</p><p><img src="DED766E8-7BB6-4B8D-B74C-1A11A4827D40.png" alt=""><br>看起来效果还很好 (光流法)</p><h5 id="6-Night-Sight-per-frame-max-333ms"><a href="#6-Night-Sight-per-frame-max-333ms" class="headerlink" title="6.Night Sight per-frame max 333ms"></a>6.Night Sight per-frame max 333ms</h5><p>也有手持跟脚架的区分<br>If the camera is being stabilized (held against a wall, or using a tripod, for example), the exposure of each frame is increased to as much as one second.</p><p>Night Sight captures 15 frames of 1/15 second (or less) each, or 6 frames of 1 second each, or anything in between</p><h5 id="6-Alignment-and-Merging"><a href="#6-Alignment-and-Merging" class="headerlink" title="6.Alignment and Merging"></a>6.Alignment and Merging</h5><p>Pixel1和Pixel2上用的是HDR+，Pixel3上用的是super res zoom</p><p>Night Sight uses a similar principle, although at full sensor resolution and not in real time. On Pixel 1 and 2 we use HDR+’s merging algorithm, modified and re-tuned to strengthen its ability to detect and reject misaligned pieces of frames, even in very noisy scenes. On Pixel 3 we use Super Res Zoom, similarly re-tuned, whether you zoom or not. While the latter was developed for super-resolution, it also works to reduce noise, since it averages multiple images together. Super Res Zoom produces better results for some nighttime scenes than HDR+, but it requires the faster processor of the Pixel 3.</p><h5 id="7-Other-challenges"><a href="#7-Other-challenges" class="headerlink" title="7. Other challenges"></a>7. Other challenges</h5><p>AWB in low light<br> The AWB algorithm used in non-Night Sight modes is good, but in very dim or <u>strongly colored lighting</u> (think sodium vapor lamps), it’s hard to decide what color the illumination is.</p><p>To solve these problems, we developed a <a href="https://ai.google/research/pubs/pub46440" target="_blank" rel="noopener">learning-based AWB algorithm</a>, trained to discriminate between a well-white-balanced image and a poorly balanced one. When a captured image is poorly balanced, the algorithm can suggest how to shift its colors to make the illumination appear more neutral. Training this algorithm required photographing a diversity of scenes using Pixel phones, then hand-correcting their white balance while looking at the photo on a color-calibrated monitor.</p><p><img src="9ED3DE07-DB17-4D5F-BF03-10704717B59D.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-关于ZSL的Flow-为什么谷歌相机和华为的能秒拍？&quot;&gt;&lt;a href=&quot;#1-关于ZSL的Flow-为什么谷歌相机和华为的能秒拍？&quot; class=&quot;headerlink&quot; title=&quot;1.关于ZSL的Flow 为什么谷歌相机和华为的能秒拍？&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>用友元函数进行解耦合</title>
    <link href="https://allen52.top/2020/07/19/reconstraction/"/>
    <id>https://allen52.top/2020/07/19/reconstraction/</id>
    <published>2020-07-19T12:21:15.000Z</published>
    <updated>2020-08-02T14:14:52.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h1><p>背景：公司Hal3解耦 目前的方式单纯的是隔离代码，不能做成一个框架。从SAT解耦工作中，发现其实在policy这个地方是可以做成一套框架的，因为policy这个地方改的地方很多，包括sensorSetting，featureSetting，还有关于SAT的requestSensorSetting，这些改动对于不同平台来讲我们希望可以做成或者做到差异化，再进一步我们需要把不同项目配置独立成config文件来达到组件化的目的，所以终极目标是mtkHal3-&gt;call interface-&gt;call module-&gt;call proj config。首先是在mtk的code中call到我们的interface，再进入interface后，首先call到通用的module code，module code可以按照功能性进行划分，比如RequestSensorSettingPolicy会call到sensorDecsion 这样设计，模块划分就很清晰，甚至SensorSettingPolicy中我们可以再定义module来处理native app以及3rd party app的 sensorsetting逻辑。如果有项目区分的部分，我们再考虑读取不同项目的config文件进一步做到by project这种粒度。</p><p>围绕interface module 到config file，下面需要进行下一步需求拆解：</p><h5 id="1-interface"><a href="#1-interface" class="headerlink" title="1.interface"></a>1.interface</h5><p>目前阶段 interface其实已经有了，只是形式很丑陋，都是通过宏定义 或者extend class这种形式，本质上还是在native class基础上加上classs member，所谓的interface如果依靠这种形式，就无法做到代码重用。因此 interface需要设计：</p><p>SAT解耦工作中，动的最大的地方就是policy的部分，因为涉及到很多自定义meta更新，以及自定义策略。所以先从这块开刀：</p><blockquote><p>interface：<br>policyAdapter：public class：IPolicy</p></blockquote><p>这里用一个继承policy的interface作为我们的基类，在这个基类里面我们也可以添加不同的virtual function<br>在基类基础上我们可以定义子类了：</p><blockquote><p>FeatureSettingPolicyAdapter：policyAdapter<br>SensorSettingPolicyAdapter：policyAdapter<br>RequestSensorSettingPolicyAdapter：policyAdapter<br>这里的子类是为业务服务的，因此就参考mtk native hal3的设计来做。</p></blockquote><p>因为涉及到类比较多，基本原则是mtk native class里面一个class插入一个adpater的指针，因此我们还需要：<br>PolicyAdapterManager<br>PolicyAdapterFactory<br>我们希望所有的Policy类都只需要一个Manager类来管理，Manager类管理所有PolicyAdapter的生命周期。Manager成员一定需要是全局的，而且需要提供static函数接口进行管理（比如创建一个policyAdapter并返回其指针）</p><p>Factory需不需要这个再考虑</p><h5 id="interface设计技术"><a href="#interface设计技术" class="headerlink" title="interface设计技术"></a>interface设计技术</h5><p>interface的需求是，less code as possible<br>最好是：</p><ol><li>native class里面只需要定义一个成员变量，该变量是Adapter类指针</li><li>当在成员函数中需要call到 我们的interface的时候 只需要一行code ：<br>Manager::getAdapter(“FeatureSetting”)-&gt;doDecision(this);</li><li>不需要care内存问题</li></ol><p>其实这样做当初就有想做，但是问题是需要定义一个类 这个类是native class的成员变量，但是还要做到在native class中call 这个类的interface 需要把当前的class的class member暴露给它，当时略微思考了一下觉得不可能做得到的。而且解耦的工作做完后又有其他的活了，所以当时没有考虑这个问题。今天认真思考了一下，用友元是可以做到的。不过得多加一句：<br>friend class PolicyAdapter；</p><p>简单的试了一下，做了一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Policy.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PolicyAdapter.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> featureName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Policy(<span class="built_in">string</span> featureName_,PolicyAdapter* pa);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doDecision</span><span class="params">()</span></span>;</span><br><span class="line">    ~Policy();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyAdapter</span>;</span></span><br><span class="line">    PolicyAdapter* p;<span class="comment">//&lt;- 这里是我们的interface类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Policy.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Policy.h"</span></span></span><br><span class="line"></span><br><span class="line">Policy::Policy(<span class="built_in">string</span> featureName_, PolicyAdapter* pa)</span><br><span class="line">:featureName(featureName_)</span><br><span class="line">, p(pa)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Policy::~Policy()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Policy::doDecision</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p-&gt;Interface(<span class="keyword">this</span>);<span class="comment">//&lt;- call interface接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PolicyAdapter.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolicyAdapter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">module</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PolicyAdapter(<span class="built_in">string</span> module_);</span><br><span class="line">    ~PolicyAdapter();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Interface</span><span class="params">(Policy *a)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PolicyAdapter.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Policy.h"</span></span></span><br><span class="line"></span><br><span class="line">PolicyAdapter::PolicyAdapter(<span class="built_in">string</span> module_)</span><br><span class="line">:<span class="keyword">module</span>(module_)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolicyAdapter::Interface</span><span class="params">(Policy *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Module:  "</span> &lt;&lt; <span class="keyword">module</span> &lt;&lt; <span class="string">" FeatureName: "</span>&lt;&lt;a-&gt;featureName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PolicyAdapter::~PolicyAdapter()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main.cpp:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Policy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> policy_adpater = make_shared&lt;PolicyAdapter&gt;(<span class="string">"A Policy Adapter"</span>);</span><br><span class="line">    <span class="keyword">auto</span> policy = make_shared&lt;Policy&gt;(<span class="string">"FeatureSetting"</span>,policy_adpater.get());</span><br><span class="line">    policy-&gt;doDecision();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果：<br>g++ main2.cpp Policy.cpp PolicyAdapter.cpp -o a2.out -std=c++14</p><blockquote><p>Module: A Policy Adapter FeatureName: FeatureSetting</p></blockquote><p>以前的问题现在看起来可以通过友元类来解决，c++真是太牛逼了</p><h5 id="Manager类设计"><a href="#Manager类设计" class="headerlink" title="Manager类设计"></a>Manager类设计</h5><p>manager类的设计周一去公司再参考一下native class的设计吧，比较麻烦的一个点是policy的类是一个session持有的，manager类不能设计成单例，如果是单例肯定有问题。Adapter类的生命周期应该是在它依附的native class上。<br>我目前希望做到的是通过这种形式调用：<br>Manager::getAdapter(“FeatureSetting”)-&gt;Interface(this);<br>目前想到一个办法是把this指针作为key来索引对应的Adapter指针，这样在析构的时候把这对map删除掉，传参一定要指定module这样相对于知道了ptr类型，这样的话那就只需要这样传参了：<br>Manager::getAdapter(“FeatureSetting”)-&gt;Interface();<br>this指针在构造的时候就已经给到Manager，Manager也能传给Adapter实例了。</p><h5 id="关于内存"><a href="#关于内存" class="headerlink" title="关于内存"></a>关于内存</h5><p>内存管理上我比较倾向于C++11的智能指针，因为这种形式基本不需要对于内存做过多的管理了。</p><p>按照以上的思路重新改了一下demo：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Policy.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PolicyAdapter.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> featureName;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Policy(<span class="built_in">string</span> featureName_,<span class="built_in">string</span> module_);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doDecision</span><span class="params">()</span></span>;</span><br><span class="line">    ~Policy();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">PolicyAdapter</span>;</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;PolicyAdapter&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Policy.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Policy.h"</span></span></span><br><span class="line"></span><br><span class="line">Policy::Policy(<span class="built_in">string</span> featureName_,<span class="built_in">string</span> module_)</span><br><span class="line">:featureName(featureName_)</span><br><span class="line">,<span class="keyword">module</span>(module_)</span><br><span class="line">&#123;</span><br><span class="line">    p = make_shared&lt;PolicyAdapter&gt;(<span class="keyword">module</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Policy::~Policy()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Policy::doDecision</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p-&gt;Interface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PolicyAdapter.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Policy</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolicyAdapter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">module</span>;</span><br><span class="line">    Policy* a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PolicyAdapter(<span class="built_in">string</span> module_,Policy* input);</span><br><span class="line">    ~PolicyAdapter();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Interface</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PolicyAdapter.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Policy.h"</span></span></span><br><span class="line"></span><br><span class="line">PolicyAdapter::PolicyAdapter(<span class="built_in">string</span> module_,Policy* input)</span><br><span class="line">:<span class="keyword">module</span>(module_)</span><br><span class="line">,a(input)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PolicyAdapter::Interface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Module: "</span> &lt;&lt; <span class="keyword">module</span> &lt;&lt; <span class="string">" FeatureName: "</span>&lt;&lt;a-&gt;featureName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PolicyAdapter::~PolicyAdapter()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数中现在看不到任何policyAdapter的痕迹，因为其都是在Policy中的管理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Policy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> policy = make_shared&lt;Policy&gt;(<span class="string">"FeatureSetting"</span>,<span class="string">"A PolicyAdapter"</span>);</span><br><span class="line">    policy-&gt;doDecision();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解耦&quot;&gt;&lt;a href=&quot;#解耦&quot; class=&quot;headerlink&quot; title=&quot;解耦&quot;&gt;&lt;/a&gt;解耦&lt;/h1&gt;&lt;p&gt;背景：公司Hal3解耦 目前的方式单纯的是隔离代码，不能做成一个框架。从SAT解耦工作中，发现其实在policy这个地方是可以做成一套框架的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter4</title>
    <link href="https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter4/"/>
    <id>https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter4/</id>
    <published>2020-07-19T11:59:59.000Z</published>
    <updated>2020-07-19T12:19:16.203Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变参模板"><a href="#变参模板" class="headerlink" title="变参模板"></a>变参模板</h4><p>从 C++11 开始，模板可以接受一组数量可变的参数。这样就可以在参数数量和参数类型都不 确定的情况下使用模板。一个典型应用是通过 class 或者 framework 向模板传递一组数量和 类型都不确定的参数。</p><p>可以将模板参数定义成能够接受任意多个模板参数的情况。这一类模板被称为变参模板 （variadic template)</p><h5 id="变参模板实例"><a href="#变参模板实例" class="headerlink" title="变参模板实例"></a>变参模板实例</h5><p>如果传入的参数是一个或者多个，就会调用这个函数模板，这里通过将第一个参数单独声明， 就可以先打印第一个参数，然后再递归的调用 print()来打印剩余的参数。这些被称为 args 的剩余参数，是一个函数参数包（function parameter pack）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T FirstArg, Types... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; FirstArg &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先被扩展成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="keyword">double</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; (<span class="number">7.5</span>, <span class="string">"hello"</span>, s);</span><br></pre></td></tr></table></figure><p>打印第一个参数后，继续被扩展为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="keyword">char</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; (<span class="string">"hello"</span>, s);</span><br></pre></td></tr></table></figure><p>打印了“hello”后，继续调用print()打印剩余参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; (s);</span><br></pre></td></tr></table></figure><p>最后后调用重载的不接受参数的非模板函数print()</p><h5 id="变参和非变参模板的重载"><a href="#变参和非变参模板的重载" class="headerlink" title="变参和非变参模板的重载"></a>变参和非变参模板的重载</h5><p>还可以这么实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arg &lt;&lt; ’\n’; <span class="comment">//print passed argument</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>… Types&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types… args)</span> </span>&#123;</span><br><span class="line">        print(firstArg); <span class="comment">// call print() for the first argument</span></span><br><span class="line">        print(args…); <span class="comment">// call print() for remainingarguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当两个函数模板的区别只在于尾部的参数包的时候，会优先选择没有尾部参数包 的那一个函数模板</p><p>c++为变参模板引入了一个新的sizeof运算符：sizeof…，它会被扩展成参数包中所包含的参数数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>… Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types… args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; ’\n’; <span class="comment">//print first argument </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>…(Types) &lt;&lt; ’\n’; <span class="comment">//print number of remaining types </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>…(args) &lt;&lt; ’\n’; <span class="comment">//print number of remainingargs …</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>c++11新特性参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/102419965?utm_source=cn.wiz.note" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102419965?utm_source=cn.wiz.note</a></p><p><a href="https://shaharmike.com/cpp/lambdas-and-functions/" target="_blank" rel="noopener">https://shaharmike.com/cpp/lambdas-and-functions/</a></p></blockquote><h4 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h4><p>从 C++17 开始，提供了一种可以用来计算参数包（可以有初始值）中所有参数运算结果的二 元运算符</p><table><thead><tr><th>Fold Expression</th><th>Evaluation</th></tr></thead><tbody><tr><td>( … oppack)</td><td>((( pack1 op pack2 ) op pack3 ) … op packN )</td></tr><tr><td>(packop … )</td><td>( pack1 op ( … ( packN-1 op packN )))</td></tr><tr><td>(initop … oppack)</td><td>(((initoppack1)oppack2) … oppackN)</td></tr><tr><td>(packop … opinit)</td><td>(pack1op( … (packNopinit)))</td></tr></tbody></table><p>例如 下面的函数会返回s中的所有参数的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span><span class="params">(T... s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (... + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎所有的二元运算符都可以用于折叠表达式(详情请参见 12.4.6 节)。比如可以使用折叠表达式和运算符-&gt;*遍历一条二叉树的路径:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node* left;</span><br><span class="line">Node* right;</span><br><span class="line">Node(<span class="keyword">int</span> i=<span class="number">0</span>) : value(i),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> left = &amp;Node::left;</span><br><span class="line"><span class="keyword">auto</span> right = &amp;Node::right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... TP&gt; </span><br><span class="line"><span class="function">Node* <span class="title">traverse</span> <span class="params">(T np, TP... paths)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (np-&gt;* ... -&gt;*paths);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* root = <span class="keyword">new</span> Node&#123;<span class="number">0</span>&#125;;</span><br><span class="line">root-&gt;left = <span class="keyword">new</span> Node&#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;left-&gt;right = <span class="keyword">new</span> Node&#123;<span class="number">2</span>&#125;;</span><br><span class="line">Node* node = traverse(root,left,right);</span><br><span class="line">print(node-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样一个使用了初始化器的折叠表达式，似乎可以简化打印变参模板参数的过程,不过这样在参数包各元素之间并不会打印空格。为了打印空格，还需要下面这样一个类模板， 它可以在所有要打印的参数后面追加一个空格:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddSpace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T <span class="keyword">const</span>&amp; ref;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">AddSpace(T <span class="keyword">const</span>&amp;r): ref(r) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp; os, AddSpace&lt;T&gt; s) &#123;</span><br><span class="line"><span class="keyword">return</span> os&lt;&lt;s.ref&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; ... &lt;&lt; AddSpace&lt;Args&gt;(args)) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变参模板的使用"><a href="#变参模板的使用" class="headerlink" title="变参模板的使用"></a>变参模板的使用</h4><p>一个重要的作用是转发任意类型和数量的参数，比如在如下情况下会使用这一特性:<br>向一个由智能指针管理的，在堆中创建的对象的构造函数传递参数:</p><blockquote><p>auto sp = std::make_shared&lt;std::complex<float>&gt;(4.2, 7.7);</p></blockquote><p>向一个由库启动的thread传递参数:</p><blockquote><p>std::thread t (foo, 42, “hello”); //call foo(42,”hello”) in a separate thread</p></blockquote><p>向一个被push进vector中的对象的构造函数传递参数:</p><blockquote><p>std::vector<Customer> v;<br>v.emplace(“Tim”, “Jovi”, 1962); </p></blockquote><p>前关于常规模板参数的规则同样适用于变参模板参数。比如，如果参数是按值传递 的，那么其参数会被拷贝，类型也会退化(decay)。如果是按引用传递的，那么参数会是 实参的引用，并且类型不会退化</p><h4 id="变参类模板和变参表达式"><a href="#变参类模板和变参表达式" class="headerlink" title="变参类模板和变参表达式"></a>变参类模板和变参表达式</h4><p>除了上面提到的例子，参数包还可以出现在其它一些地方，比如表达式，类模板，using 声明，甚至是推断指引中</p><h5 id="变参表达式"><a href="#变参表达式" class="headerlink" title="变参表达式"></a>变参表达式</h5><p>除了转发所有参数之外，还可以做些别的事情。比如计算它们的值<br>下面的例子先是将参数包中的所有的参数都翻倍，然后将结果传给 print():</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubled</span> <span class="params">(T <span class="keyword">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (args + args...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这样调用它：</p><blockquote><p>printDoubled(7.5, std::string(“hello”), std::complex<float>(4,2));</p></blockquote><p>效果和下面的调用相同：</p><blockquote><p>print(7.5 + 7.5, std::string(“hello”) + std::string(“hello”), std::complex<float>(4,2) + std::complex<float>(4,2);</p></blockquote><p>如果只是想向每个参数加 1，省略号…中的点不能紧跟在数值后面:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOne</span> <span class="params">(T <span class="keyword">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (args + <span class="number">1.</span>..); <span class="comment">// ERROR: 1... is a literal with too many decimal points</span></span><br><span class="line">    print (args + <span class="number">1</span> ...); <span class="comment">// OK</span></span><br><span class="line">    print ((args + <span class="number">1</span>)...); <span class="comment">// OK </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译阶段的表达式同样可以像上面那样包含模板参数包。比如下面这个例子可以用来判断所有参数包中参数的类型是否相同:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... TN&gt; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">isHomogeneous</span> <span class="params">(T1, TN...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::is_same&lt;T1,TN&gt;::value &amp;&amp; ...); <span class="comment">// since C++17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是折叠表达式的一种应用(参见 4.2 节)。对于:</p><blockquote><p>isHomogeneous(43, -1, “hello”)</p></blockquote><p>会被扩展成:</p><blockquote><p>std::is_same&lt;int,int&gt;::value &amp;&amp; std::is_same&lt;int,char const*&gt;::value</p></blockquote><p>结果自然是 false。而对:</p><blockquote><p>isHomogeneous(“hello”, “”, “world”, “!”)</p></blockquote><p>结果则是 true(这里因为是按值传递，所以 发生了类型退还)</p><h5 id="变参下标"><a href="#变参下标" class="headerlink" title="变参下标"></a>变参下标</h5><p>作为另外一个例子，下面的函数通过一组变参下标来访问第一个参数中相应的元素:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Idx&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElems</span> <span class="params">(C <span class="keyword">const</span>&amp; coll, Idx... idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (coll[idx]...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用:</p><blockquote><p>std::vector<a href="std::string">std::string</a> coll = {“good”, “times”, “say”, “bye”};<br>printElems(coll,2,0,3);</p></blockquote><p>相对于调用了：</p><blockquote><p>print (coll[2], coll[0], coll[3]);</p></blockquote><p>也可以将非类型模板参数声明成参数包。比如对:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>... Idx, <span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIdx</span> <span class="params">(C <span class="keyword">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(coll[Idx]...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样调用:</p><blockquote><p>std::vector<a href="std::string">std::string</a> coll = {“good”, “times”, “say”, “bye”};<br>printIdx&lt;2,0,3&gt;(coll);</p></blockquote><h5 id="变参类模板"><a href="#变参类模板" class="headerlink" title="变参类模板"></a>变参类模板</h5><p>类模板也可以是变参的。一个重要的例子是，通过任意多个模板参数指定了 class 相应数据 成员的类型:</p><blockquote><p>template&lt;typename… Elements&gt;class Tuple;<br>Tuple&lt;int, std::string, char&gt; t;</p></blockquote><p>另一个例子是指定对象可能包含的类型:</p><blockquote><p>template&lt;typename… Types&gt;<br>class Variant;<br>Variant&lt;int, std::string, char&gt; v; // v can hold integer, string, or character</p></blockquote><p>也可以将 class 定义成代表了一组下表的类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type for arbitrary number of indices: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>...&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Indices</span> &#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用它定义一个通过 print()打印 std::array 或者 std::tuple 中元素的函数，具体打印哪些元 素由编译阶段的 get&lt;&gt;从给定的下标中获取:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span>... Idx&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printByIdx</span><span class="params">(T t, Indices&lt;Idx...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="built_in">std</span>::get&lt;Idx&gt;(t)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以像下面这样使用这个模板:</p><blockquote><p>std::array&lt;std::string, 5&gt; arr = {“Hello”, “my”, “new”, “!”, “World”};<br>printByIdx(arr, Indices&lt;0, 4, 3&gt;());</p></blockquote><p>或者像下面这样:</p><blockquote><p>auto t = std::make_tuple(12, “monkeys”, 2.0);<br>printByIdx(t, Indices&lt;0, 1, 2&gt;());</p></blockquote><p>这是迈向元编程(meta-programming)的第一步</p><h5 id="变惨推断指引"><a href="#变惨推断指引" class="headerlink" title="变惨推断指引"></a>变惨推断指引</h5><p>推断指引也是可以变参的，比如在C++标准库中，为 std::array 定义了如下推断指引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">template&lt;typename T, typename... U&gt; array(T, U...)</span><br><span class="line">-&gt; <span class="built_in">array</span>&lt;<span class="keyword">enable_if_t</span>&lt;(is_same_v&lt;T, U&gt; &amp;&amp; ...), T&gt;, (<span class="number">1</span> + <span class="keyword">sizeof</span>...(U))&gt;; &#125;</span><br></pre></td></tr></table></figure><p>针对这样的初始化:</p><blockquote><p>std::array a{42,45,77};</p></blockquote><p>会将指引中的 T 推断为 array(首)元素的类型，而 U…会被推断为剩余元素的类型。因此 array 中元素总数目是 1 + sizeof…(U)，等效于如下声明:</p><blockquote><p>std::array&lt;int, 3&gt; a{42,45,77};</p></blockquote><p>array 第一个参的操作 std::enable_if&lt;&gt;是一个折叠表达式(和 4.1 节中的 isHomogeneous()情况类似)，可以展开成这样:</p><blockquote><p>is_same_v&lt;T, U1&gt; &amp;&amp; is_same_v&lt;T, U2&gt; &amp;&amp; is_same_v&lt;T, U3&gt; …</p></blockquote><p>如果结果是 false(也就是说 array 中元素不是同一种类型)，推断指引会被弃用，总的类型推断失败。这样标准库就可以确保在推断指引成功的情况下，所有元素都是同一种类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;变参模板&quot;&gt;&lt;a href=&quot;#变参模板&quot; class=&quot;headerlink&quot; title=&quot;变参模板&quot;&gt;&lt;/a&gt;变参模板&lt;/h4&gt;&lt;p&gt;从 C++11 开始，模板可以接受一组数量可变的参数。这样就可以在参数数量和参数类型都不 确定的情况下使用模板。一个典型应用
      
    
    </summary>
    
    
    
      <category term="C++" scheme="https://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter3</title>
    <link href="https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter3/"/>
    <id>https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter3/</id>
    <published>2020-07-19T11:59:56.000Z</published>
    <updated>2020-07-19T12:12:21.701Z</updated>
    
    <content type="html"><![CDATA[<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>对于之前介绍的函数模板和类模板，其模板参数不一定非得是某种具体的类型，也可以是常 规数值。和类模板使用类型作为参数类似，可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数，待定的不再是类型，而是某个数值。</p><h5 id="类模板的非类型参数"><a href="#类模板的非类型参数" class="headerlink" title="类模板的非类型参数"></a>类模板的非类型参数</h5><p>例：将Stack的大小定义为模板的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T,Maxsize&gt; elems;</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> numElems;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Stack();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line">Stack&lt;T,Maxsize&gt;::Stack()</span><br><span class="line">:numElems(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Maxsize&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    assert(numElems &lt; Maxsize);</span><br><span class="line">    elems[numElems] = elem;</span><br><span class="line">    ++numElems;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Maxsize&gt;::pop() &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    --numElems;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line">T <span class="keyword">const</span>&amp; Stack&lt;T,Maxsize&gt;::top() <span class="keyword">const</span>&#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    <span class="keyword">return</span> elems[numElems<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次模板的使用都会实例化出一个新的类型。因此 int20Stack 和 int40Stack 是两种不 同的类型.</p><h5 id="函数模板的非类型参数"><a href="#函数模板的非类型参数" class="headerlink" title="函数模板的非类型参数"></a>函数模板的非类型参数</h5><p>同样也可以给函数模板定义非类型模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> Val, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addValue</span> <span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + Val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非类型模板参数的限制"><a href="#非类型模板参数的限制" class="headerlink" title="非类型模板参数的限制"></a>非类型模板参数的限制</h5><p>使用非类型模板参数是有限制的。</p><blockquote><p>通常它们只能是整形常量（包含枚举），<br>指向 objects/functions/members 的指针，<br>objects 或者 functions 的左值引用，<br>或者是 std::nullptr_t （类型是 nullptr）。</p></blockquote><h5 id="用auto作为非模板类型参数的类型"><a href="#用auto作为非模板类型参数的类型" class="headerlink" title="用auto作为非模板类型参数的类型"></a>用auto作为非模板类型参数的类型</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>模板的参数不只可以是类型，也可以是数值。<br>不可以将浮点型或者 class 类型的对象用于非类型模板参数。使用指向字符串常量，临 时变量和子对象的指针或引用也有一些限制。<br>通过使用关键字 auto，可以使非类型模板参数的类型更为泛化</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;非类型模板参数&quot;&gt;&lt;a href=&quot;#非类型模板参数&quot; class=&quot;headerlink&quot; title=&quot;非类型模板参数&quot;&gt;&lt;/a&gt;非类型模板参数&lt;/h4&gt;&lt;p&gt;对于之前介绍的函数模板和类模板，其模板参数不一定非得是某种具体的类型，也可以是常 规数值。和类模板使
      
    
    </summary>
    
    
    
      <category term="C++" scheme="https://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter2</title>
    <link href="https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter2/"/>
    <id>https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter2/</id>
    <published>2020-07-19T11:59:42.000Z</published>
    <updated>2020-07-19T12:11:04.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章：类模板"><a href="#第二章：类模板" class="headerlink" title="第二章：类模板"></a>第二章：类模板</h1><h4 id="Stack类模板的实现"><a href="#Stack类模板的实现" class="headerlink" title="Stack类模板的实现"></a>Stack类模板的实现</h4><p>Stack类模板的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line"><span class="comment">// return whether the stack is empty </span></span><br><span class="line"><span class="keyword">return</span> elems.empty(); </span><br><span class="line">&#125; </span><br><span class="line">    Stack (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    Stack$ <span class="keyword">operator</span>= (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop () &#123;</span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> elems.pop_back(); </span><br><span class="line"> <span class="comment">// remove last element </span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"> T <span class="keyword">const</span>&amp; Stack&lt;T&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> <span class="keyword">return</span> elems.back(); </span><br><span class="line"> <span class="comment">// return copy of last element </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="声明一个类模板"><a href="#声明一个类模板" class="headerlink" title="声明一个类模板"></a>声明一个类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line"><span class="comment">// return whether the stack is empty </span></span><br><span class="line"><span class="keyword">return</span> elems.empty(); </span><br><span class="line">&#125; </span><br><span class="line">    Stack (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    Stack$ <span class="keyword">operator</span>= (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="comment">/**********************OR********************/</span></span><br><span class="line">    Stack (Stack&lt;T&gt; <span class="keyword">const</span>&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    Stack&lt;T&gt;&amp; <span class="keyword">operator</span>= (Stack&lt;T&gt; <span class="keyword">const</span>&amp;); <span class="comment">// assignment operator </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于非模板类，不可以在函数内部或者块作用域内（{…}）声明和定义模板。通常 模板只能定义在 global/namespace 作用域</p><h5 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h5><p>定义类模板的成员函数时，必须指出它是一个模板，也必须使用该类模板的所有类型限制。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop () &#123;</span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> elems.pop_back(); </span><br><span class="line"> <span class="comment">// remove last element </span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"> T <span class="keyword">const</span>&amp; Stack&lt;T&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> <span class="keyword">return</span> elems.back(); </span><br><span class="line"> <span class="comment">// return copy of last element </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="Stack类模板的使用"><a href="#Stack类模板的使用" class="headerlink" title="Stack类模板的使用"></a>Stack类模板的使用</h5><p>通过声明 Stack<int>类型，在类模板内部 int 会被用作类型 T。被创建的 instStack 会使用一个 存储 int 的 vector 作为其 elems 成员，而且所有被用到的成员函数都会被用 int 实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt; <span class="keyword">int</span>&gt; intStack; <span class="comment">// stack of ints </span></span><br><span class="line">    Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringStack; <span class="comment">// stack of strings </span></span><br><span class="line">    <span class="comment">// manipulate int stack </span></span><br><span class="line">    intStack.push(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intStack.top() &lt;&lt; ’\n’; <span class="comment">// manipulate string stack </span></span><br><span class="line">    stringStack.push(<span class="string">"hello"</span>); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stringStack.top() &lt;&lt; ’\n’;</span><br><span class="line">    stringStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，模板函数和模板成员函数只有在被调用的时候才会实例化<br>在这个例子中，对 int 和 std::string，默认构造函数，push()以及 top()函数都会被实例化, 。而 pop()只会针对 std::string 实例化</p><h5 id="部分地使用类模板"><a href="#部分地使用类模板" class="headerlink" title="部分地使用类模板"></a>部分地使用类模板</h5><p>一个类模板通常会对用来实例化它的类型进行多种操作（包含构造函数和析构函数）。这可 能会让你以为，要为模板参数提供所有被模板成员函数用到的操作.但是事实不是这样：模板参数只需要提供那些会被用到的操作（而不是可能会被用到的操作）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="keyword">const</span>&amp; elem : elems) &#123; </span><br><span class="line">            strm &lt;&lt; elem &lt;&lt; ’ ’; <span class="comment">// call &lt;&lt; for each element</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类依然可以用于那些没有提供 operator&lt;&lt;运算符的元素:只有在调用 printOn()的时候，才会导致错误</p><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>相比于通过 printOn()来打印 stack 的内容，更好的办法是去重载 stack 的 operator&lt;&lt;运算符。 而且和非模板类的情况一样，operator&lt;&lt;应该被实现为非成员函数，在其实现中可以调用 printOn()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    … </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    … </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp; strm, Stack&lt;T&gt; <span class="keyword">const</span>&amp; s) &#123;</span><br><span class="line">        s.printOn(strm); </span><br><span class="line">        <span class="keyword">return</span> strm; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而如果你试着先声明一个友元函数，然后再去定义它，情况会变的很复杂。事实上我们有 两种选择：<br>先将 Stack<T>的 operator&lt;&lt;声明为一个模板，这要求先对 Stack<T>进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>;</span> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp;, Stack&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br></pre></td></tr></table></figure><p>接着就可以将这一模板声明为 Stack<T>的友元： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt; (<span class="built_in">std</span>::ostream&amp;, Stack&lt;T&gt; </span><br><span class="line">    <span class="keyword">const</span>&amp;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板类的特例化"><a href="#模板类的特例化" class="headerlink" title="模板类的特例化"></a>模板类的特例化</h4><p>为了特化一个类模板，在类模板声明的前面需要有一个 template&lt;&gt;，并且需要指明所希望特 化的类型。这些用于特化类模板的类型被用作模板参数，并且需要紧跟在类名的后面： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt; &#123;</span> </span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于被特化的模板，所有成员函数的定义都应该被定义成“常规”成员函数，也就是说所有 出现 T 的地方，都应该被替换成用于特化类模板的类型： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">    elems.push_back(elem); </span><br><span class="line">    <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个用 std::string 实例化 Stack&lt;&gt;类模板的完整例子： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt; &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; elems; <span class="comment">// elements </span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::pop () &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="部分特例化"><a href="#部分特例化" class="headerlink" title="部分特例化"></a>部分特例化</h5><p>类模板可以只被部分的特例化。这样就可以为某些特殊情况提供特殊的实现，不过使用者还 是要定义一部分模板参数。比如，可以特殊化一个 Stack&lt;&gt;来专门处理指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="comment">// partial specialization of class Stack&lt;&gt; for pointers: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;T*&gt; &#123;</span> </span><br><span class="line">    Private: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T*&gt; elems; <span class="comment">// elements </span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T*)</span></span>; <span class="comment">// push element </span></span><br><span class="line">        <span class="function">T* <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">        <span class="function">T* <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T*&gt;::push (T* elem) &#123; </span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">T* Stack&lt;T*&gt;::pop () &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    T* p = elems.back(); </span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// and return it (unlike in the general case) </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">T* Stack&lt;T*&gt;::top () <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多模板参数的部分特例化"><a href="#多模板参数的部分特例化" class="headerlink" title="多模板参数的部分特例化"></a>多模板参数的部分特例化</h5><p>类模板也可以特例化多个模板参数之间的关系。比如对下面这个类模板： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进行如下这些特例化都是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partial specialization: both template parameters have same type </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T,T&gt; &#123;</span> </span><br><span class="line">…</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// partial specialization: second type is int </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T,int&gt; &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// partial specialization: both template parameters are pointer types </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T1*,T2*&gt; &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="默认类模板参数"><a href="#默认类模板参数" class="headerlink" title="默认类模板参数"></a>默认类模板参数</h4><p>和函数模板一样，也可以给类模板的模板参数指定默认值。比如对 Stack&lt;&gt;，你可以将其用 来容纳元素的容器声明为第二个模板参数，并指定其默认值是 std::vector&lt;&gt;: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Cont elems; <span class="comment">// elements </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">    <span class="keyword">return</span> elems.empty(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt; </span><br><span class="line">    <span class="keyword">void</span> Stack&lt;T,Cont&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Cont&gt;::pop () &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line">T <span class="keyword">const</span>&amp; Stack&lt;T,Cont&gt;::top () <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Stack&lt;&gt;模板可以像之前一样使用。如果只提供第一个模板参数作为元素类型，那么 vector 将被用来处理 Stack 中的元素：<br>而且在程序中，也可以为 Stack 指定一个容器类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack of doubles using a std::deque&lt;&gt; to manage the elements </span></span><br><span class="line">Stack&lt; <span class="keyword">double</span>,<span class="built_in">std</span>::<span class="built_in">deque</span>&lt; <span class="keyword">double</span>&gt;&gt; dblStack;</span><br></pre></td></tr></table></figure><h5 id="类别名"><a href="#类别名" class="headerlink" title="类别名"></a>类别名</h5><p>Typedefs 和 Alias 声明<br>1.使用关键字typedef:  <code>typedef Stack&lt;int&gt; IntStack; // typedef</code><br>2.使用关键字using:  <code>using IntStack = Stack &lt;int&gt;; // alias declaration</code></p><p>以上两种给一个已经存在的类型定义新名字的方式，被称为 type alias declaration。新的名字 被称为 type alias。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> DequeStack = Stack&lt;T, <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>DequeStack别名模板是被T参数化的</p><h5 id="类模板的类型推导"><a href="#类模板的类型推导" class="headerlink" title="类模板的类型推导"></a>类模板的类型推导</h5><p>直到 C++17，使用类模板时都必须<strong>显式指出所有的模板参数的类型</strong>（除非它们有默认值）。 从 C++17 开始，这一要求不在那么严格了。如果构造函数能够推断出所有模板参数的类型（对 那些没有默认值的模板参数），就不再需要显式的指明模板参数的类型。<br>比如可以定义 下面这样一个 Stack，它可以被一个元素初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Stack () = <span class="keyword">default</span>; </span><br><span class="line">        Stack (T <span class="keyword">const</span>&amp; elem) <span class="comment">// initialize stack with one element </span></span><br><span class="line">        : elems(&#123;elem&#125;) &#123; &#125;</span><br><span class="line">        …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后可以这样声明一个Stack：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack intStack = <span class="number">0</span>; <span class="comment">// Stack&lt;int&gt; deduced since C++17</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二章：类模板&quot;&gt;&lt;a href=&quot;#第二章：类模板&quot; class=&quot;headerlink&quot; title=&quot;第二章：类模板&quot;&gt;&lt;/a&gt;第二章：类模板&lt;/h1&gt;&lt;h4 id=&quot;Stack类模板的实现&quot;&gt;&lt;a href=&quot;#Stack类模板的实现&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="C++" scheme="https://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter1</title>
    <link href="https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter1/"/>
    <id>https://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter1/</id>
    <published>2020-07-19T11:57:42.000Z</published>
    <updated>2020-07-19T12:02:03.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：函数模板"><a href="#第一章：函数模板" class="headerlink" title="第一章：函数模板"></a>第一章：函数模板</h1><h4 id="两阶段编译检查-Two-Phase-Translation"><a href="#两阶段编译检查-Two-Phase-Translation" class="headerlink" title="两阶段编译检查 (Two-Phase Translation)"></a>两阶段编译检查 (Two-Phase Translation)</h4><p><strong>1.定义阶段:</strong> 模板的检查并不包含类型参数的检查</p><blockquote><p>语法检查。比如少了分号<br>使用了未定义的不依赖于模板参数的名称（类型名，函数名，……）。<br>未使用模板参数的 staticassertions</p></blockquote><p><strong>2.模板实例化阶段:</strong>  确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分</p><h4 id="类型推断中的类型转换"><a href="#类型推断中的类型转换" class="headerlink" title="类型推断中的类型转换"></a>类型推断中的类型转换</h4><p>在类型推断的时候自动的类型转换是受限制的：</p><blockquote><p>参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的 两个参数，它们实参的类型必须完全一样。</p></blockquote><p>调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的： const 和 volatile 限制符会被忽略，引用被转换成被引用的类型，rawarray 和函数被转换为相 应的指针类型。通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。</p><p>但是像下面这样是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR: 不确定T该被推断为int还是double</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">foo(<span class="string">"hello"</span>, s); <span class="comment">//ERROR: 不确定T该被推断为 const[6] 还是 std::string</span></span><br></pre></td></tr></table></figure><p>解决方法：强制转换，指定类型，多个模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>), <span class="number">7.2</span>); <span class="comment">// OK</span></span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// OK</span></span><br><span class="line">指明调用参数可能有不同的类型（多个模板参数）。</span><br></pre></td></tr></table></figure><h4 id="对默认调用参数的类型推断"><a href="#对默认调用参数的类型推断" class="headerlink" title="对默认调用参数的类型推断"></a>对默认调用参数的类型推断</h4><p>类型推断并不适用于默认调用参数。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T = <span class="string">""</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ERROR: 无法推断T的类型</span></span><br></pre></td></tr></table></figure><p>为应对这一情况，你需要给模板类型参数也声明一个默认参数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="built_in">std</span>::<span class="built_in">string</span>&gt; </span><br><span class="line">viod foo(T = <span class="string">""</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"foo called"</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候需要加上：<br>g++ -std=c++11 main.cpp -o test</p><h4 id="多个模板参数"><a href="#多个模板参数" class="headerlink" title="多个模板参数"></a>多个模板参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function">T1 <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以接受两个不同类型的调用参数。但是如示例代码所示，这也导致了 一个问题。如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地 一样，当应该返回另一个类型的值的时候，返回值会被做类型转换</p><p>C++提供了多种应对这一问题的方法：</p><blockquote><p>引入第三个模板参数作为返回类型。<br>让编译器找出返回类型。<br>将返回类型定义为两个参数类型的公共类型</p></blockquote><h5 id="作为返回类型的模板参数"><a href="#作为返回类型的模板参数" class="headerlink" title="作为返回类型的模板参数"></a>作为返回类型的模板参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">::max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>);</span><br></pre></td></tr></table></figure><p>调用 max<double>时，显式的指明了 RT 的类型是 double</p><h5 id="返回类型推断"><a href="#返回类型推断" class="headerlink" title="返回类型推断"></a>返回类型推断</h5><p>推断返回类型最简单也是最好的办法就是让编译器 来做这件事</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不使用 尾 置 返 回 类 型 （ trailingreturntype ） 的 情 况 下 将 auto 用于返回类型，要求 <strong>返回类型必须能够通过函数体中的返回语句推断出来</strong>。</p><p>在 C++11 中，尾置返回类型（trailingreturntype）允许我们使用函数的调用参数。 也就是说，我们可以基于运算符?:的结果声明返回类型： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line">auto max (T1 a, T2 b) -&gt; decltype(true?a:b);</span><br></pre></td></tr></table></figure><p>由于 T 可能是引用类型，返回类型就也可能被推断 为引用类型。因此你应该返回的是 decay 后的 T，像下面这样： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto max (T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true? a:b)&gt;::type &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们用到了类型萃取 <strong>（typetrait）std::decay&lt;&gt;</strong> ，它返回其 type 成员作为目标类型， 定义在标准库<type_trait>中（参见 D.5）。由于其 type 成员是一个类型，为了获取其结果， 需要用关键字 typename 修饰这个表达式。</p><h5 id="将返回类型声明为（common-type）"><a href="#将返回类型声明为（common-type）" class="headerlink" title="将返回类型声明为（common type）"></a>将返回类型声明为（common type）</h5><p>从 C++11 开始，标准库提供了一种指定“更一般类型”的方式。std::common_type&lt;&gt;::type 产生的类型是他的两个模板参数的公共类型。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">std::common_type_t&lt;T1,T2&gt; max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h4><p>可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT =</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="literal">true</span> ? T1() : T2())&gt;&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用类型萃取 common_type作为返回类型的默认值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT = <span class="built_in">std</span>::<span class="keyword">common_type_t</span>&lt;T1,T2&gt;&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了显式指出返回类型，我们必须显式的指出全部三个 模板参数的类型。因此我们希望能够将返回类型作为第一个模板参数，并且依然能够从其它两个模板参数推断出它的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT = <span class="keyword">long</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是只有当模板参数具有一个“天生的”默认值时，这才有意义。我们真正想要的是从前面 的模板参数推导出想要的默认值。</p><p>基于以上原因，最好也是最简单的办法是<strong>让编译器来推断出返回类型</strong></p><h4 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maximum of two int values:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b &lt; a ? a : b; &#125;</span><br><span class="line"><span class="comment">// maximum of two values of any type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::max(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls the nontemplate for two ints</span></span><br><span class="line">    ::max(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">    ::max(’a’, ’b’); <span class="comment">//calls max&lt;char&gt; (by argument deduction)</span></span><br><span class="line">    ::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;int&gt; (by argumentdeduction)</span></span><br><span class="line">    ::max&lt;<span class="keyword">double</span>&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;double&gt; (no argumentdeduction)</span></span><br><span class="line">    ::max(’a’, <span class="number">42.7</span>); <span class="comment">//calls the nontemplate for two ints</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非模板函数可以与其同名的函数模板共存，函数模板可以被实例化为与非模板函数具有相同的调用参数。模板解析过程优先选择非模板函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::max(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls the nontemplate for two ints</span></span><br></pre></td></tr></table></figure><p>如果模板可以实例化一个更匹配的函数，那么会选择这个模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::max(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">::max(’a’, ’b’); <span class="comment">//calls max&lt;char&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure><p>也可以显式指定一个空的模板列表，表明它会被解析成一个模板使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>模板参数推断时不允许自动类型转换，常规函数是允许的，因此最后一个调用会选择非模板函数</p><p>confused：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//像下面这样调用 max():</span></span><br><span class="line"><span class="keyword">auto</span> a = ::max(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// uses first template</span></span><br><span class="line"><span class="keyword">auto</span> b = ::max&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;(<span class="number">7.2</span>, <span class="number">4</span>); <span class="comment">// uses second template</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//error：</span></span><br><span class="line"><span class="keyword">auto</span> c = ::max&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR: both function templates match</span></span><br></pre></td></tr></table></figure><p>两个模板都是匹配的，这会导致模板解析过程不知道该调用哪一个模板，从而导致未知错误，当重载函数模板的时候，你要保证对任意一个调用，都只会有一个模板匹配。</p><p>为指针和c字符串重载max()模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // maximum of two values of any type:</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of two pointers: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">max</span> <span class="params">(T* a, T* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *b &lt; *a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of two C-strings: </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">max</span> <span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* a, <span class="keyword">char</span> <span class="keyword">const</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>; </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">42</span>; </span><br><span class="line">    <span class="keyword">auto</span> m1 = ::max(a,b); <span class="comment">// max() for two values of type int 【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"hey"</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">"you"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m2 = ::max(s1,s2); <span class="comment">// max() for two values of type  std::string 【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p1 = &amp;b; </span><br><span class="line">    <span class="keyword">int</span>* p2 = &amp;a; </span><br><span class="line">    <span class="keyword">auto</span> m3 = ::max(p1,p2); <span class="comment">// max() for two pointers【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* x = <span class="string">"hello"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* y = <span class="string">"world"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m4 = ::max(x,y); <span class="comment">// max() for two C-strings【OK】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。 否则，可能会遇到意想不到的问题:<br>比如，如果你实现了一个按引用传递的 max()模板，然 后又重载了一个按值传递两个 C 字符串作为参数的模板，你不能用接受三个参数的模板来计 算三个 C 字符串的最大值： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type (call-by-reference) </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125; <span class="comment">// maximum of two C-strings (call-by-value) </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">max</span> <span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* a, <span class="keyword">char</span> <span class="keyword">const</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// maximum of three values of any type (call-by-reference) </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b, T <span class="keyword">const</span>&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max (max(a,b), c); <span class="comment">//  【 error if max(a,b) uses call-by-value 】</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m1 = ::max(<span class="number">7</span>, <span class="number">42</span>, <span class="number">68</span>); <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s1 = <span class="string">"frederic"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s2 = <span class="string">"anica"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s3 = <span class="string">"lucas"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m2 = ::max(s1, s2, s3); <span class="comment">//run-time ERROR </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试了一下 gcc编译的时候好像可以检查出来：</p><blockquote><p>warning：returning reference to temporary</p></blockquote><p>需要确保函数模板在调用时，其已经在前面已经被定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max&lt;T&gt;() \n"</span>;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of three values of any type: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b, T c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> max (max(a,b), c); </span><br><span class="line">    <span class="comment">// uses the template version even for ints </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//because the following declaration comes </span></span><br><span class="line"><span class="comment">// too late: </span></span><br><span class="line"><span class="comment">// maximum of two int values: </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(int,int) \n"</span>; </span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    ::max(<span class="number">47</span>,<span class="number">11</span>,<span class="number">33</span>); <span class="comment">// OOPS: uses max&lt;T&gt;() instead of max(int,int) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后会出现：</p><blockquote><p>max<T>()<br>max<T>()</p></blockquote><p>调用的是上面的模板函数</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="按值传递还是按引用"><a href="#按值传递还是按引用" class="headerlink" title="按值传递还是按引用"></a>按值传递还是按引用</h5><p><strong>问题一：</strong> 为什么我们声明的函数通常都是按值传递，而不是按引用传递。通常而 言，建议将按引用传递用于除简单类型（比如基础类型和 std::string_view）以外的类型，这 样可以免除不必要的拷贝成本</p><p>不过出于以下原因，按值传递通常更好一些： </p><blockquote><p>语法简单。<br>编译器能够更好地进行优化。<br>移动语义通常使拷贝成本比较低。<br>某些情况下可能没有拷贝或者移动。</p></blockquote><p>对于模板，还有一些特有情况：</p><blockquote><p>模板既可以用于简单类型，也可以用于复杂类型，因此如果默认选择适合于复杂类型可 能方式，可能会对简单类型产生不利影响</p></blockquote><p>虽然按值传递 stringliteral 和 rawarray 经常会遇到问题，但是按照引用传递它们通常只 会遇到更大的问题。第 7 章会对此做进一步讨论</p><p><strong>问题二：</strong>  为什么不适用 inline？</p><p>通常而言，函数模板不需要被声明成 inline。不同于非 inline 函数，我们可以把非 inline 的函 数模板定义在头文件里，然后在多个编译单元里 include 这个文件。</p><p>唯一一个例外是模板对某些类型的全特化，这时候最终的 code 不在是“泛型”的（所有的 模板参数都已被指定）。</p><p>严格从语言角度来看，inline只意味着在程序中函数的定义可以出现很多次，不过它也给 了编译器一个暗示，在调用该函数的地方函数应该被展开成 inline 的：这样做在某些情况下 可以提高效率，但是在另一些情况下也可能降低效率。现代编译器在没有关键字 inline 暗示 的情况下，通常也可以很好的决定是否将函数展开成 inline 的。</p><p><strong>问题三：</strong> 为什么不用constexpr<br>为了可以在编译阶段使用求最大值的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此你就可以在编译阶段的上下文中，实时地使用这个求最大值的函数模板： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[::max(<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="number">1000u</span>)];</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><blockquote><p>函数模板定义了一组适用于不同类型的函数。</p><p>当向模板函数传递变量时，函数模板会自行推断模板参数的类型，来决定去实例化出那 种类型的函数。</p><p>你也可以显式的指出模板参数的类型。 </p><p>你可以定义模板参数的默认值。</p><p>这个默认值可以使用该模板参数前面的模板参数的类 型，而且其后面的模板参数可以没有默认值。</p><p>函数模板可以被重载。</p><p>当定义新的函数模板来重载已有的函数模板时，必须要确保在任何调用情况下都只有一 个模板是最匹配的。</p><p>当你重载函数模板的时候，最好只是显式地指出了模板参数得了类型。</p><p>确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章：函数模板&quot;&gt;&lt;a href=&quot;#第一章：函数模板&quot; class=&quot;headerlink&quot; title=&quot;第一章：函数模板&quot;&gt;&lt;/a&gt;第一章：函数模板&lt;/h1&gt;&lt;h4 id=&quot;两阶段编译检查-Two-Phase-Translation&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
      <category term="C++" scheme="https://allen52.top/tags/C/"/>
    
  </entry>
  
</feed>
