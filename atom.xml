<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Steve&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://allen52.top/"/>
  <updated>2020-07-19T12:19:16.203Z</updated>
  <id>http://allen52.top/</id>
  
  <author>
    <name>Steve</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ template ReadingNote-Chapter4</title>
    <link href="http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter4/"/>
    <id>http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter4/</id>
    <published>2020-07-19T11:59:59.000Z</published>
    <updated>2020-07-19T12:19:16.203Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变参模板"><a href="#变参模板" class="headerlink" title="变参模板"></a>变参模板</h4><p>从 C++11 开始，模板可以接受一组数量可变的参数。这样就可以在参数数量和参数类型都不 确定的情况下使用模板。一个典型应用是通过 class 或者 framework 向模板传递一组数量和 类型都不确定的参数。</p><p>可以将模板参数定义成能够接受任意多个模板参数的情况。这一类模板被称为变参模板 （variadic template)</p><h5 id="变参模板实例"><a href="#变参模板实例" class="headerlink" title="变参模板实例"></a>变参模板实例</h5><p>如果传入的参数是一个或者多个，就会调用这个函数模板，这里通过将第一个参数单独声明， 就可以先打印第一个参数，然后再递归的调用 print()来打印剩余的参数。这些被称为 args 的剩余参数，是一个函数参数包（function parameter pack）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T FirstArg, Types... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; FirstArg &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先被扩展成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="keyword">double</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; (<span class="number">7.5</span>, <span class="string">"hello"</span>, s);</span><br></pre></td></tr></table></figure><p>打印第一个参数后，继续被扩展为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="keyword">char</span> <span class="keyword">const</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; (<span class="string">"hello"</span>, s);</span><br></pre></td></tr></table></figure><p>打印了“hello”后，继续调用print()打印剩余参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; (s);</span><br></pre></td></tr></table></figure><p>最后后调用重载的不接受参数的非模板函数print()</p><h5 id="变参和非变参模板的重载"><a href="#变参和非变参模板的重载" class="headerlink" title="变参和非变参模板的重载"></a>变参和非变参模板的重载</h5><p>还可以这么实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arg &lt;&lt; ’\n’; <span class="comment">//print passed argument</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>… Types&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types… args)</span> </span>&#123;</span><br><span class="line">        print(firstArg); <span class="comment">// call print() for the first argument</span></span><br><span class="line">        print(args…); <span class="comment">// call print() for remainingarguments</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当两个函数模板的区别只在于尾部的参数包的时候，会优先选择没有尾部参数包 的那一个函数模板</p><p>c++为变参模板引入了一个新的sizeof运算符：sizeof…，它会被扩展成参数包中所包含的参数数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>… Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(T firstArg, Types… args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; ’\n’; <span class="comment">//print first argument </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>…(Types) &lt;&lt; ’\n’; <span class="comment">//print number of remaining types </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>…(args) &lt;&lt; ’\n’; <span class="comment">//print number of remainingargs …</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>c++11新特性参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/102419965?utm_source=cn.wiz.note" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102419965?utm_source=cn.wiz.note</a></p><p><a href="https://shaharmike.com/cpp/lambdas-and-functions/" target="_blank" rel="noopener">https://shaharmike.com/cpp/lambdas-and-functions/</a></p></blockquote><h4 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h4><p>从 C++17 开始，提供了一种可以用来计算参数包（可以有初始值）中所有参数运算结果的二 元运算符</p><table><thead><tr><th>Fold Expression</th><th>Evaluation</th></tr></thead><tbody><tr><td>( … oppack)</td><td>((( pack1 op pack2 ) op pack3 ) … op packN )</td></tr><tr><td>(packop … )</td><td>( pack1 op ( … ( packN-1 op packN )))</td></tr><tr><td>(initop … oppack)</td><td>(((initoppack1)oppack2) … oppackN)</td></tr><tr><td>(packop … opinit)</td><td>(pack1op( … (packNopinit)))</td></tr></tbody></table><p>例如 下面的函数会返回s中的所有参数的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foldSum</span><span class="params">(T... s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (... + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎所有的二元运算符都可以用于折叠表达式(详情请参见 12.4.6 节)。比如可以使用折叠表达式和运算符-&gt;*遍历一条二叉树的路径:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">Node* left;</span><br><span class="line">Node* right;</span><br><span class="line">Node(<span class="keyword">int</span> i=<span class="number">0</span>) : value(i),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> left = &amp;Node::left;</span><br><span class="line"><span class="keyword">auto</span> right = &amp;Node::right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... TP&gt; </span><br><span class="line"><span class="function">Node* <span class="title">traverse</span> <span class="params">(T np, TP... paths)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (np-&gt;* ... -&gt;*paths);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* root = <span class="keyword">new</span> Node&#123;<span class="number">0</span>&#125;;</span><br><span class="line">root-&gt;left = <span class="keyword">new</span> Node&#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;left-&gt;right = <span class="keyword">new</span> Node&#123;<span class="number">2</span>&#125;;</span><br><span class="line">Node* node = traverse(root,left,right);</span><br><span class="line">print(node-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样一个使用了初始化器的折叠表达式，似乎可以简化打印变参模板参数的过程,不过这样在参数包各元素之间并不会打印空格。为了打印空格，还需要下面这样一个类模板， 它可以在所有要打印的参数后面追加一个空格:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddSpace</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T <span class="keyword">const</span>&amp; ref;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">AddSpace(T <span class="keyword">const</span>&amp;r): ref(r) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp; os, AddSpace&lt;T&gt; s) &#123;</span><br><span class="line"><span class="keyword">return</span> os&lt;&lt;s.ref&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; ... &lt;&lt; AddSpace&lt;Args&gt;(args)) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变参模板的使用"><a href="#变参模板的使用" class="headerlink" title="变参模板的使用"></a>变参模板的使用</h4><p>一个重要的作用是转发任意类型和数量的参数，比如在如下情况下会使用这一特性:<br>向一个由智能指针管理的，在堆中创建的对象的构造函数传递参数:</p><blockquote><p>auto sp = std::make_shared&lt;std::complex<float>&gt;(4.2, 7.7);</p></blockquote><p>向一个由库启动的thread传递参数:</p><blockquote><p>std::thread t (foo, 42, “hello”); //call foo(42,”hello”) in a separate thread</p></blockquote><p>向一个被push进vector中的对象的构造函数传递参数:</p><blockquote><p>std::vector<Customer> v;<br>v.emplace(“Tim”, “Jovi”, 1962); </p></blockquote><p>前关于常规模板参数的规则同样适用于变参模板参数。比如，如果参数是按值传递 的，那么其参数会被拷贝，类型也会退化(decay)。如果是按引用传递的，那么参数会是 实参的引用，并且类型不会退化</p><h4 id="变参类模板和变参表达式"><a href="#变参类模板和变参表达式" class="headerlink" title="变参类模板和变参表达式"></a>变参类模板和变参表达式</h4><p>除了上面提到的例子，参数包还可以出现在其它一些地方，比如表达式，类模板，using 声明，甚至是推断指引中</p><h5 id="变参表达式"><a href="#变参表达式" class="headerlink" title="变参表达式"></a>变参表达式</h5><p>除了转发所有参数之外，还可以做些别的事情。比如计算它们的值<br>下面的例子先是将参数包中的所有的参数都翻倍，然后将结果传给 print():</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDoubled</span> <span class="params">(T <span class="keyword">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (args + args...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这样调用它：</p><blockquote><p>printDoubled(7.5, std::string(“hello”), std::complex<float>(4,2));</p></blockquote><p>效果和下面的调用相同：</p><blockquote><p>print(7.5 + 7.5, std::string(“hello”) + std::string(“hello”), std::complex<float>(4,2) + std::complex<float>(4,2);</p></blockquote><p>如果只是想向每个参数加 1，省略号…中的点不能紧跟在数值后面:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOne</span> <span class="params">(T <span class="keyword">const</span>&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (args + <span class="number">1.</span>..); <span class="comment">// ERROR: 1... is a literal with too many decimal points</span></span><br><span class="line">    print (args + <span class="number">1</span> ...); <span class="comment">// OK</span></span><br><span class="line">    print ((args + <span class="number">1</span>)...); <span class="comment">// OK </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译阶段的表达式同样可以像上面那样包含模板参数包。比如下面这个例子可以用来判断所有参数包中参数的类型是否相同:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span>... TN&gt; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">isHomogeneous</span> <span class="params">(T1, TN...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">std</span>::is_same&lt;T1,TN&gt;::value &amp;&amp; ...); <span class="comment">// since C++17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是折叠表达式的一种应用(参见 4.2 节)。对于:</p><blockquote><p>isHomogeneous(43, -1, “hello”)</p></blockquote><p>会被扩展成:</p><blockquote><p>std::is_same&lt;int,int&gt;::value &amp;&amp; std::is_same&lt;int,char const*&gt;::value</p></blockquote><p>结果自然是 false。而对:</p><blockquote><p>isHomogeneous(“hello”, “”, “world”, “!”)</p></blockquote><p>结果则是 true(这里因为是按值传递，所以 发生了类型退还)</p><h5 id="变参下标"><a href="#变参下标" class="headerlink" title="变参下标"></a>变参下标</h5><p>作为另外一个例子，下面的函数通过一组变参下标来访问第一个参数中相应的元素:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Idx&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElems</span> <span class="params">(C <span class="keyword">const</span>&amp; coll, Idx... idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print (coll[idx]...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用:</p><blockquote><p>std::vector<a href="std::string">std::string</a> coll = {“good”, “times”, “say”, “bye”};<br>printElems(coll,2,0,3);</p></blockquote><p>相对于调用了：</p><blockquote><p>print (coll[2], coll[0], coll[3]);</p></blockquote><p>也可以将非类型模板参数声明成参数包。比如对:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>... Idx, <span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIdx</span> <span class="params">(C <span class="keyword">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(coll[Idx]...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样调用:</p><blockquote><p>std::vector<a href="std::string">std::string</a> coll = {“good”, “times”, “say”, “bye”};<br>printIdx&lt;2,0,3&gt;(coll);</p></blockquote><h5 id="变参类模板"><a href="#变参类模板" class="headerlink" title="变参类模板"></a>变参类模板</h5><p>类模板也可以是变参的。一个重要的例子是，通过任意多个模板参数指定了 class 相应数据 成员的类型:</p><blockquote><p>template&lt;typename… Elements&gt;class Tuple;<br>Tuple&lt;int, std::string, char&gt; t;</p></blockquote><p>另一个例子是指定对象可能包含的类型:</p><blockquote><p>template&lt;typename… Types&gt;<br>class Variant;<br>Variant&lt;int, std::string, char&gt; v; // v can hold integer, string, or character</p></blockquote><p>也可以将 class 定义成代表了一组下表的类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type for arbitrary number of indices: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>...&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Indices</span> &#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用它定义一个通过 print()打印 std::array 或者 std::tuple 中元素的函数，具体打印哪些元 素由编译阶段的 get&lt;&gt;从给定的下标中获取:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span>... Idx&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printByIdx</span><span class="params">(T t, Indices&lt;Idx...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="built_in">std</span>::get&lt;Idx&gt;(t)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以像下面这样使用这个模板:</p><blockquote><p>std::array&lt;std::string, 5&gt; arr = {“Hello”, “my”, “new”, “!”, “World”};<br>printByIdx(arr, Indices&lt;0, 4, 3&gt;());</p></blockquote><p>或者像下面这样:</p><blockquote><p>auto t = std::make_tuple(12, “monkeys”, 2.0);<br>printByIdx(t, Indices&lt;0, 1, 2&gt;());</p></blockquote><p>这是迈向元编程(meta-programming)的第一步</p><h5 id="变惨推断指引"><a href="#变惨推断指引" class="headerlink" title="变惨推断指引"></a>变惨推断指引</h5><p>推断指引也是可以变参的，比如在C++标准库中，为 std::array 定义了如下推断指引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">template&lt;typename T, typename... U&gt; array(T, U...)</span><br><span class="line">-&gt; <span class="built_in">array</span>&lt;<span class="keyword">enable_if_t</span>&lt;(is_same_v&lt;T, U&gt; &amp;&amp; ...), T&gt;, (<span class="number">1</span> + <span class="keyword">sizeof</span>...(U))&gt;; &#125;</span><br></pre></td></tr></table></figure><p>针对这样的初始化:</p><blockquote><p>std::array a{42,45,77};</p></blockquote><p>会将指引中的 T 推断为 array(首)元素的类型，而 U…会被推断为剩余元素的类型。因此 array 中元素总数目是 1 + sizeof…(U)，等效于如下声明:</p><blockquote><p>std::array&lt;int, 3&gt; a{42,45,77};</p></blockquote><p>array 第一个参的操作 std::enable_if&lt;&gt;是一个折叠表达式(和 4.1 节中的 isHomogeneous()情况类似)，可以展开成这样:</p><blockquote><p>is_same_v&lt;T, U1&gt; &amp;&amp; is_same_v&lt;T, U2&gt; &amp;&amp; is_same_v&lt;T, U3&gt; …</p></blockquote><p>如果结果是 false(也就是说 array 中元素不是同一种类型)，推断指引会被弃用，总的类型推断失败。这样标准库就可以确保在推断指引成功的情况下，所有元素都是同一种类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;变参模板&quot;&gt;&lt;a href=&quot;#变参模板&quot; class=&quot;headerlink&quot; title=&quot;变参模板&quot;&gt;&lt;/a&gt;变参模板&lt;/h4&gt;&lt;p&gt;从 C++11 开始，模板可以接受一组数量可变的参数。这样就可以在参数数量和参数类型都不 确定的情况下使用模板。一个典型应用
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter3</title>
    <link href="http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter3/"/>
    <id>http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter3/</id>
    <published>2020-07-19T11:59:56.000Z</published>
    <updated>2020-07-19T12:12:21.701Z</updated>
    
    <content type="html"><![CDATA[<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>对于之前介绍的函数模板和类模板，其模板参数不一定非得是某种具体的类型，也可以是常 规数值。和类模板使用类型作为参数类似，可以使代码的另一些细节留到被使用时再确定， 只是对非类型模板参数，待定的不再是类型，而是某个数值。</p><h5 id="类模板的非类型参数"><a href="#类模板的非类型参数" class="headerlink" title="类模板的非类型参数"></a>类模板的非类型参数</h5><p>例：将Stack的大小定义为模板的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">array</span>&lt;T,Maxsize&gt; elems;</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> numElems;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Stack();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> numElems;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line">Stack&lt;T,Maxsize&gt;::Stack()</span><br><span class="line">:numElems(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Maxsize&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    assert(numElems &lt; Maxsize);</span><br><span class="line">    elems[numElems] = elem;</span><br><span class="line">    ++numElems;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Maxsize&gt;::pop() &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    --numElems;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> Maxsize&gt;</span><br><span class="line">T <span class="keyword">const</span>&amp; Stack&lt;T,Maxsize&gt;::top() <span class="keyword">const</span>&#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    <span class="keyword">return</span> elems[numElems<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次模板的使用都会实例化出一个新的类型。因此 int20Stack 和 int40Stack 是两种不 同的类型.</p><h5 id="函数模板的非类型参数"><a href="#函数模板的非类型参数" class="headerlink" title="函数模板的非类型参数"></a>函数模板的非类型参数</h5><p>同样也可以给函数模板定义非类型模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> Val, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">addValue</span> <span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + Val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非类型模板参数的限制"><a href="#非类型模板参数的限制" class="headerlink" title="非类型模板参数的限制"></a>非类型模板参数的限制</h5><p>使用非类型模板参数是有限制的。</p><blockquote><p>通常它们只能是整形常量（包含枚举），<br>指向 objects/functions/members 的指针，<br>objects 或者 functions 的左值引用，<br>或者是 std::nullptr_t （类型是 nullptr）。</p></blockquote><h5 id="用auto作为非模板类型参数的类型"><a href="#用auto作为非模板类型参数的类型" class="headerlink" title="用auto作为非模板类型参数的类型"></a>用auto作为非模板类型参数的类型</h5><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>模板的参数不只可以是类型，也可以是数值。<br>不可以将浮点型或者 class 类型的对象用于非类型模板参数。使用指向字符串常量，临 时变量和子对象的指针或引用也有一些限制。<br>通过使用关键字 auto，可以使非类型模板参数的类型更为泛化</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;非类型模板参数&quot;&gt;&lt;a href=&quot;#非类型模板参数&quot; class=&quot;headerlink&quot; title=&quot;非类型模板参数&quot;&gt;&lt;/a&gt;非类型模板参数&lt;/h4&gt;&lt;p&gt;对于之前介绍的函数模板和类模板，其模板参数不一定非得是某种具体的类型，也可以是常 规数值。和类模板使
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter2</title>
    <link href="http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter2/"/>
    <id>http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter2/</id>
    <published>2020-07-19T11:59:42.000Z</published>
    <updated>2020-07-19T12:11:04.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章：类模板"><a href="#第二章：类模板" class="headerlink" title="第二章：类模板"></a>第二章：类模板</h1><h4 id="Stack类模板的实现"><a href="#Stack类模板的实现" class="headerlink" title="Stack类模板的实现"></a>Stack类模板的实现</h4><p>Stack类模板的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line"><span class="comment">// return whether the stack is empty </span></span><br><span class="line"><span class="keyword">return</span> elems.empty(); </span><br><span class="line">&#125; </span><br><span class="line">    Stack (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    Stack$ <span class="keyword">operator</span>= (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop () &#123;</span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> elems.pop_back(); </span><br><span class="line"> <span class="comment">// remove last element </span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"> T <span class="keyword">const</span>&amp; Stack&lt;T&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> <span class="keyword">return</span> elems.back(); </span><br><span class="line"> <span class="comment">// return copy of last element </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="声明一个类模板"><a href="#声明一个类模板" class="headerlink" title="声明一个类模板"></a>声明一个类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line"><span class="comment">// return whether the stack is empty </span></span><br><span class="line"><span class="keyword">return</span> elems.empty(); </span><br><span class="line">&#125; </span><br><span class="line">    Stack (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    Stack$ <span class="keyword">operator</span>= (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="comment">/**********************OR********************/</span></span><br><span class="line">    Stack (Stack&lt;T&gt; <span class="keyword">const</span>&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    Stack&lt;T&gt;&amp; <span class="keyword">operator</span>= (Stack&lt;T&gt; <span class="keyword">const</span>&amp;); <span class="comment">// assignment operator </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于非模板类，不可以在函数内部或者块作用域内（{…}）声明和定义模板。通常 模板只能定义在 global/namespace 作用域</p><h5 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h5><p>定义类模板的成员函数时，必须指出它是一个模板，也必须使用该类模板的所有类型限制。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop () &#123;</span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> elems.pop_back(); </span><br><span class="line"> <span class="comment">// remove last element </span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"> T <span class="keyword">const</span>&amp; Stack&lt;T&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line"> assert(!elems.empty()); </span><br><span class="line"> <span class="keyword">return</span> elems.back(); </span><br><span class="line"> <span class="comment">// return copy of last element </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="Stack类模板的使用"><a href="#Stack类模板的使用" class="headerlink" title="Stack类模板的使用"></a>Stack类模板的使用</h5><p>通过声明 Stack<int>类型，在类模板内部 int 会被用作类型 T。被创建的 instStack 会使用一个 存储 int 的 vector 作为其 elems 成员，而且所有被用到的成员函数都会被用 int 实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt; <span class="keyword">int</span>&gt; intStack; <span class="comment">// stack of ints </span></span><br><span class="line">    Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringStack; <span class="comment">// stack of strings </span></span><br><span class="line">    <span class="comment">// manipulate int stack </span></span><br><span class="line">    intStack.push(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intStack.top() &lt;&lt; ’\n’; <span class="comment">// manipulate string stack </span></span><br><span class="line">    stringStack.push(<span class="string">"hello"</span>); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stringStack.top() &lt;&lt; ’\n’;</span><br><span class="line">    stringStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，模板函数和模板成员函数只有在被调用的时候才会实例化<br>在这个例子中，对 int 和 std::string，默认构造函数，push()以及 top()函数都会被实例化, 。而 pop()只会针对 std::string 实例化</p><h5 id="部分地使用类模板"><a href="#部分地使用类模板" class="headerlink" title="部分地使用类模板"></a>部分地使用类模板</h5><p>一个类模板通常会对用来实例化它的类型进行多种操作（包含构造函数和析构函数）。这可 能会让你以为，要为模板参数提供所有被模板成员函数用到的操作.但是事实不是这样：模板参数只需要提供那些会被用到的操作（而不是可能会被用到的操作）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="keyword">const</span>&amp; elem : elems) &#123; </span><br><span class="line">            strm &lt;&lt; elem &lt;&lt; ’ ’; <span class="comment">// call &lt;&lt; for each element</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类依然可以用于那些没有提供 operator&lt;&lt;运算符的元素:只有在调用 printOn()的时候，才会导致错误</p><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>相比于通过 printOn()来打印 stack 的内容，更好的办法是去重载 stack 的 operator&lt;&lt;运算符。 而且和非模板类的情况一样，operator&lt;&lt;应该被实现为非成员函数，在其实现中可以调用 printOn()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    … </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    … </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp; strm, Stack&lt;T&gt; <span class="keyword">const</span>&amp; s) &#123;</span><br><span class="line">        s.printOn(strm); </span><br><span class="line">        <span class="keyword">return</span> strm; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而如果你试着先声明一个友元函数，然后再去定义它，情况会变的很复杂。事实上我们有 两种选择：<br>先将 Stack<T>的 operator&lt;&lt;声明为一个模板，这要求先对 Stack<T>进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>;</span> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp;, Stack&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br></pre></td></tr></table></figure><p>接着就可以将这一模板声明为 Stack<T>的友元： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt; (<span class="built_in">std</span>::ostream&amp;, Stack&lt;T&gt; </span><br><span class="line">    <span class="keyword">const</span>&amp;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板类的特例化"><a href="#模板类的特例化" class="headerlink" title="模板类的特例化"></a>模板类的特例化</h4><p>为了特化一个类模板，在类模板声明的前面需要有一个 template&lt;&gt;，并且需要指明所希望特 化的类型。这些用于特化类模板的类型被用作模板参数，并且需要紧跟在类名的后面： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt; &#123;</span> </span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于被特化的模板，所有成员函数的定义都应该被定义成“常规”成员函数，也就是说所有 出现 T 的地方，都应该被替换成用于特化类模板的类型： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">    elems.push_back(elem); </span><br><span class="line">    <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个用 std::string 实例化 Stack&lt;&gt;类模板的完整例子： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt; &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; elems; <span class="comment">// elements </span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::pop () &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="部分特例化"><a href="#部分特例化" class="headerlink" title="部分特例化"></a>部分特例化</h5><p>类模板可以只被部分的特例化。这样就可以为某些特殊情况提供特殊的实现，不过使用者还 是要定义一部分模板参数。比如，可以特殊化一个 Stack&lt;&gt;来专门处理指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="comment">// partial specialization of class Stack&lt;&gt; for pointers: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;T*&gt; &#123;</span> </span><br><span class="line">    Private: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T*&gt; elems; <span class="comment">// elements </span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T*)</span></span>; <span class="comment">// push element </span></span><br><span class="line">        <span class="function">T* <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">        <span class="function">T* <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T*&gt;::push (T* elem) &#123; </span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">T* Stack&lt;T*&gt;::pop () &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    T* p = elems.back(); </span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// and return it (unlike in the general case) </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">T* Stack&lt;T*&gt;::top () <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多模板参数的部分特例化"><a href="#多模板参数的部分特例化" class="headerlink" title="多模板参数的部分特例化"></a>多模板参数的部分特例化</h5><p>类模板也可以特例化多个模板参数之间的关系。比如对下面这个类模板： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进行如下这些特例化都是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partial specialization: both template parameters have same type </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T,T&gt; &#123;</span> </span><br><span class="line">…</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// partial specialization: second type is int </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T,int&gt; &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// partial specialization: both template parameters are pointer types </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T1*,T2*&gt; &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="默认类模板参数"><a href="#默认类模板参数" class="headerlink" title="默认类模板参数"></a>默认类模板参数</h4><p>和函数模板一样，也可以给类模板的模板参数指定默认值。比如对 Stack&lt;&gt;，你可以将其用 来容纳元素的容器声明为第二个模板参数，并指定其默认值是 std::vector&lt;&gt;: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Cont elems; <span class="comment">// elements </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">    <span class="keyword">return</span> elems.empty(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt; </span><br><span class="line">    <span class="keyword">void</span> Stack&lt;T,Cont&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Cont&gt;::pop () &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line">T <span class="keyword">const</span>&amp; Stack&lt;T,Cont&gt;::top () <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Stack&lt;&gt;模板可以像之前一样使用。如果只提供第一个模板参数作为元素类型，那么 vector 将被用来处理 Stack 中的元素：<br>而且在程序中，也可以为 Stack 指定一个容器类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack of doubles using a std::deque&lt;&gt; to manage the elements </span></span><br><span class="line">Stack&lt; <span class="keyword">double</span>,<span class="built_in">std</span>::<span class="built_in">deque</span>&lt; <span class="keyword">double</span>&gt;&gt; dblStack;</span><br></pre></td></tr></table></figure><h5 id="类别名"><a href="#类别名" class="headerlink" title="类别名"></a>类别名</h5><p>Typedefs 和 Alias 声明<br>1.使用关键字typedef:  <code>typedef Stack&lt;int&gt; IntStack; // typedef</code><br>2.使用关键字using:  <code>using IntStack = Stack &lt;int&gt;; // alias declaration</code></p><p>以上两种给一个已经存在的类型定义新名字的方式，被称为 type alias declaration。新的名字 被称为 type alias。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> DequeStack = Stack&lt;T, <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>DequeStack别名模板是被T参数化的</p><h5 id="类模板的类型推导"><a href="#类模板的类型推导" class="headerlink" title="类模板的类型推导"></a>类模板的类型推导</h5><p>直到 C++17，使用类模板时都必须<strong>显式指出所有的模板参数的类型</strong>（除非它们有默认值）。 从 C++17 开始，这一要求不在那么严格了。如果构造函数能够推断出所有模板参数的类型（对 那些没有默认值的模板参数），就不再需要显式的指明模板参数的类型。<br>比如可以定义 下面这样一个 Stack，它可以被一个元素初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Stack () = <span class="keyword">default</span>; </span><br><span class="line">        Stack (T <span class="keyword">const</span>&amp; elem) <span class="comment">// initialize stack with one element </span></span><br><span class="line">        : elems(&#123;elem&#125;) &#123; &#125;</span><br><span class="line">        …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后可以这样声明一个Stack：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack intStack = <span class="number">0</span>; <span class="comment">// Stack&lt;int&gt; deduced since C++17</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二章：类模板&quot;&gt;&lt;a href=&quot;#第二章：类模板&quot; class=&quot;headerlink&quot; title=&quot;第二章：类模板&quot;&gt;&lt;/a&gt;第二章：类模板&lt;/h1&gt;&lt;h4 id=&quot;Stack类模板的实现&quot;&gt;&lt;a href=&quot;#Stack类模板的实现&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://allen52.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ template ReadingNote-Chapter1</title>
    <link href="http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter1/"/>
    <id>http://allen52.top/2020/07/19/C++%20template%20Reading%20Note-Chapter1/</id>
    <published>2020-07-19T11:57:42.000Z</published>
    <updated>2020-07-19T12:02:03.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章：函数模板"><a href="#第一章：函数模板" class="headerlink" title="第一章：函数模板"></a>第一章：函数模板</h1><h4 id="两阶段编译检查-Two-Phase-Translation"><a href="#两阶段编译检查-Two-Phase-Translation" class="headerlink" title="两阶段编译检查 (Two-Phase Translation)"></a>两阶段编译检查 (Two-Phase Translation)</h4><p><strong>1.定义阶段:</strong> 模板的检查并不包含类型参数的检查</p><blockquote><p>语法检查。比如少了分号<br>使用了未定义的不依赖于模板参数的名称（类型名，函数名，……）。<br>未使用模板参数的 staticassertions</p></blockquote><p><strong>2.模板实例化阶段:</strong>  确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分</p><h4 id="类型推断中的类型转换"><a href="#类型推断中的类型转换" class="headerlink" title="类型推断中的类型转换"></a>类型推断中的类型转换</h4><p>在类型推断的时候自动的类型转换是受限制的：</p><blockquote><p>参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的 两个参数，它们实参的类型必须完全一样。</p></blockquote><p>调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的： const 和 volatile 限制符会被忽略，引用被转换成被引用的类型，rawarray 和函数被转换为相 应的指针类型。通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。</p><p>但是像下面这样是错误的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR: 不确定T该被推断为int还是double</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">foo(<span class="string">"hello"</span>, s); <span class="comment">//ERROR: 不确定T该被推断为 const[6] 还是 std::string</span></span><br></pre></td></tr></table></figure><p>解决方法：强制转换，指定类型，多个模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>), <span class="number">7.2</span>); <span class="comment">// OK</span></span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// OK</span></span><br><span class="line">指明调用参数可能有不同的类型（多个模板参数）。</span><br></pre></td></tr></table></figure><h4 id="对默认调用参数的类型推断"><a href="#对默认调用参数的类型推断" class="headerlink" title="对默认调用参数的类型推断"></a>对默认调用参数的类型推断</h4><p>类型推断并不适用于默认调用参数。例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T = <span class="string">""</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ERROR: 无法推断T的类型</span></span><br></pre></td></tr></table></figure><p>为应对这一情况，你需要给模板类型参数也声明一个默认参数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="built_in">std</span>::<span class="built_in">string</span>&gt; </span><br><span class="line">viod foo(T = <span class="string">""</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"foo called"</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候需要加上：<br>g++ -std=c++11 main.cpp -o test</p><h4 id="多个模板参数"><a href="#多个模板参数" class="headerlink" title="多个模板参数"></a>多个模板参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function">T1 <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以接受两个不同类型的调用参数。但是如示例代码所示，这也导致了 一个问题。如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地 一样，当应该返回另一个类型的值的时候，返回值会被做类型转换</p><p>C++提供了多种应对这一问题的方法：</p><blockquote><p>引入第三个模板参数作为返回类型。<br>让编译器找出返回类型。<br>将返回类型定义为两个参数类型的公共类型</p></blockquote><h5 id="作为返回类型的模板参数"><a href="#作为返回类型的模板参数" class="headerlink" title="作为返回类型的模板参数"></a>作为返回类型的模板参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">::max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>);</span><br></pre></td></tr></table></figure><p>调用 max<double>时，显式的指明了 RT 的类型是 double</p><h5 id="返回类型推断"><a href="#返回类型推断" class="headerlink" title="返回类型推断"></a>返回类型推断</h5><p>推断返回类型最简单也是最好的办法就是让编译器 来做这件事</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不使用 尾 置 返 回 类 型 （ trailingreturntype ） 的 情 况 下 将 auto 用于返回类型，要求 <strong>返回类型必须能够通过函数体中的返回语句推断出来</strong>。</p><p>在 C++11 中，尾置返回类型（trailingreturntype）允许我们使用函数的调用参数。 也就是说，我们可以基于运算符?:的结果声明返回类型： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line">auto max (T1 a, T2 b) -&gt; decltype(true?a:b);</span><br></pre></td></tr></table></figure><p>由于 T 可能是引用类型，返回类型就也可能被推断 为引用类型。因此你应该返回的是 decay 后的 T，像下面这样： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto max (T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true? a:b)&gt;::type &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们用到了类型萃取 <strong>（typetrait）std::decay&lt;&gt;</strong> ，它返回其 type 成员作为目标类型， 定义在标准库<type_trait>中（参见 D.5）。由于其 type 成员是一个类型，为了获取其结果， 需要用关键字 typename 修饰这个表达式。</p><h5 id="将返回类型声明为（common-type）"><a href="#将返回类型声明为（common-type）" class="headerlink" title="将返回类型声明为（common type）"></a>将返回类型声明为（common type）</h5><p>从 C++11 开始，标准库提供了一种指定“更一般类型”的方式。std::common_type&lt;&gt;::type 产生的类型是他的两个模板参数的公共类型。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">std::common_type_t&lt;T1,T2&gt; max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h4><p>可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT =</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="literal">true</span> ? T1() : T2())&gt;&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用类型萃取 common_type作为返回类型的默认值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT = <span class="built_in">std</span>::<span class="keyword">common_type_t</span>&lt;T1,T2&gt;&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了显式指出返回类型，我们必须显式的指出全部三个 模板参数的类型。因此我们希望能够将返回类型作为第一个模板参数，并且依然能够从其它两个模板参数推断出它的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT = <span class="keyword">long</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是只有当模板参数具有一个“天生的”默认值时，这才有意义。我们真正想要的是从前面 的模板参数推导出想要的默认值。</p><p>基于以上原因，最好也是最简单的办法是<strong>让编译器来推断出返回类型</strong></p><h4 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maximum of two int values:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b &lt; a ? a : b; &#125;</span><br><span class="line"><span class="comment">// maximum of two values of any type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::max(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls the nontemplate for two ints</span></span><br><span class="line">    ::max(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">    ::max(’a’, ’b’); <span class="comment">//calls max&lt;char&gt; (by argument deduction)</span></span><br><span class="line">    ::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;int&gt; (by argumentdeduction)</span></span><br><span class="line">    ::max&lt;<span class="keyword">double</span>&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;double&gt; (no argumentdeduction)</span></span><br><span class="line">    ::max(’a’, <span class="number">42.7</span>); <span class="comment">//calls the nontemplate for two ints</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非模板函数可以与其同名的函数模板共存，函数模板可以被实例化为与非模板函数具有相同的调用参数。模板解析过程优先选择非模板函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::max(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls the nontemplate for two ints</span></span><br></pre></td></tr></table></figure><p>如果模板可以实例化一个更匹配的函数，那么会选择这个模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::max(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">::max(’a’, ’b’); <span class="comment">//calls max&lt;char&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure><p>也可以显式指定一个空的模板列表，表明它会被解析成一个模板使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>模板参数推断时不允许自动类型转换，常规函数是允许的，因此最后一个调用会选择非模板函数</p><p>confused：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//像下面这样调用 max():</span></span><br><span class="line"><span class="keyword">auto</span> a = ::max(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// uses first template</span></span><br><span class="line"><span class="keyword">auto</span> b = ::max&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;(<span class="number">7.2</span>, <span class="number">4</span>); <span class="comment">// uses second template</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//error：</span></span><br><span class="line"><span class="keyword">auto</span> c = ::max&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR: both function templates match</span></span><br></pre></td></tr></table></figure><p>两个模板都是匹配的，这会导致模板解析过程不知道该调用哪一个模板，从而导致未知错误，当重载函数模板的时候，你要保证对任意一个调用，都只会有一个模板匹配。</p><p>为指针和c字符串重载max()模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // maximum of two values of any type:</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of two pointers: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">max</span> <span class="params">(T* a, T* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *b &lt; *a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of two C-strings: </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">max</span> <span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* a, <span class="keyword">char</span> <span class="keyword">const</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>; </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">42</span>; </span><br><span class="line">    <span class="keyword">auto</span> m1 = ::max(a,b); <span class="comment">// max() for two values of type int 【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"hey"</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">"you"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m2 = ::max(s1,s2); <span class="comment">// max() for two values of type  std::string 【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p1 = &amp;b; </span><br><span class="line">    <span class="keyword">int</span>* p2 = &amp;a; </span><br><span class="line">    <span class="keyword">auto</span> m3 = ::max(p1,p2); <span class="comment">// max() for two pointers【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* x = <span class="string">"hello"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* y = <span class="string">"world"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m4 = ::max(x,y); <span class="comment">// max() for two C-strings【OK】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。 否则，可能会遇到意想不到的问题:<br>比如，如果你实现了一个按引用传递的 max()模板，然 后又重载了一个按值传递两个 C 字符串作为参数的模板，你不能用接受三个参数的模板来计 算三个 C 字符串的最大值： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type (call-by-reference) </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125; <span class="comment">// maximum of two C-strings (call-by-value) </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">max</span> <span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* a, <span class="keyword">char</span> <span class="keyword">const</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// maximum of three values of any type (call-by-reference) </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b, T <span class="keyword">const</span>&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max (max(a,b), c); <span class="comment">//  【 error if max(a,b) uses call-by-value 】</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m1 = ::max(<span class="number">7</span>, <span class="number">42</span>, <span class="number">68</span>); <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s1 = <span class="string">"frederic"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s2 = <span class="string">"anica"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s3 = <span class="string">"lucas"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m2 = ::max(s1, s2, s3); <span class="comment">//run-time ERROR </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试了一下 gcc编译的时候好像可以检查出来：</p><blockquote><p>warning：returning reference to temporary</p></blockquote><p>需要确保函数模板在调用时，其已经在前面已经被定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max&lt;T&gt;() \n"</span>;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of three values of any type: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b, T c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> max (max(a,b), c); </span><br><span class="line">    <span class="comment">// uses the template version even for ints </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//because the following declaration comes </span></span><br><span class="line"><span class="comment">// too late: </span></span><br><span class="line"><span class="comment">// maximum of two int values: </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(int,int) \n"</span>; </span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    ::max(<span class="number">47</span>,<span class="number">11</span>,<span class="number">33</span>); <span class="comment">// OOPS: uses max&lt;T&gt;() instead of max(int,int) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后会出现：</p><blockquote><p>max<T>()<br>max<T>()</p></blockquote><p>调用的是上面的模板函数</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="按值传递还是按引用"><a href="#按值传递还是按引用" class="headerlink" title="按值传递还是按引用"></a>按值传递还是按引用</h5><p><strong>问题一：</strong> 为什么我们声明的函数通常都是按值传递，而不是按引用传递。通常而 言，建议将按引用传递用于除简单类型（比如基础类型和 std::string_view）以外的类型，这 样可以免除不必要的拷贝成本</p><p>不过出于以下原因，按值传递通常更好一些： </p><blockquote><p>语法简单。<br>编译器能够更好地进行优化。<br>移动语义通常使拷贝成本比较低。<br>某些情况下可能没有拷贝或者移动。</p></blockquote><p>对于模板，还有一些特有情况：</p><blockquote><p>模板既可以用于简单类型，也可以用于复杂类型，因此如果默认选择适合于复杂类型可 能方式，可能会对简单类型产生不利影响</p></blockquote><p>虽然按值传递 stringliteral 和 rawarray 经常会遇到问题，但是按照引用传递它们通常只 会遇到更大的问题。第 7 章会对此做进一步讨论</p><p><strong>问题二：</strong>  为什么不适用 inline？</p><p>通常而言，函数模板不需要被声明成 inline。不同于非 inline 函数，我们可以把非 inline 的函 数模板定义在头文件里，然后在多个编译单元里 include 这个文件。</p><p>唯一一个例外是模板对某些类型的全特化，这时候最终的 code 不在是“泛型”的（所有的 模板参数都已被指定）。</p><p>严格从语言角度来看，inline只意味着在程序中函数的定义可以出现很多次，不过它也给 了编译器一个暗示，在调用该函数的地方函数应该被展开成 inline 的：这样做在某些情况下 可以提高效率，但是在另一些情况下也可能降低效率。现代编译器在没有关键字 inline 暗示 的情况下，通常也可以很好的决定是否将函数展开成 inline 的。</p><p><strong>问题三：</strong> 为什么不用constexpr<br>为了可以在编译阶段使用求最大值的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此你就可以在编译阶段的上下文中，实时地使用这个求最大值的函数模板： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[::max(<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="number">1000u</span>)];</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><blockquote><p>函数模板定义了一组适用于不同类型的函数。</p><p>当向模板函数传递变量时，函数模板会自行推断模板参数的类型，来决定去实例化出那 种类型的函数。</p><p>你也可以显式的指出模板参数的类型。 </p><p>你可以定义模板参数的默认值。</p><p>这个默认值可以使用该模板参数前面的模板参数的类 型，而且其后面的模板参数可以没有默认值。</p><p>函数模板可以被重载。</p><p>当定义新的函数模板来重载已有的函数模板时，必须要确保在任何调用情况下都只有一 个模板是最匹配的。</p><p>当你重载函数模板的时候，最好只是显式地指出了模板参数得了类型。</p><p>确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章：函数模板&quot;&gt;&lt;a href=&quot;#第一章：函数模板&quot; class=&quot;headerlink&quot; title=&quot;第一章：函数模板&quot;&gt;&lt;/a&gt;第一章：函数模板&lt;/h1&gt;&lt;h4 id=&quot;两阶段编译检查-Two-Phase-Translation&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://allen52.top/tags/C/"/>
    
  </entry>
  
</feed>
