<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ template ReadingNote-Chapter5 · Steve's Blog</title><meta name="description" content="C++ template ReadingNote-Chapter5 - Steve"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://allen52.top/atom.xml" title="Steve's Blog"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Steve's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/3616621864" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/allen52" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ template ReadingNote-Chapter5</h1><div class="post-info">Jul 21, 2020</div><div class="post-content"><h1 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h1><p>本章将涉及一些和模板实际使用有关的晋级知识，包含：关键字 typename 的使用，定义为 模板的成员函数以及嵌套类，模板参数模板（template template parameters），零初始化以 及其它一些关于使用字符串常量作为模板参数的细节讨论。这些内容有时会比较复杂，但是 作为一个 C++的日常使用者，应该至少已经听说过它们了</p>
<h4 id="typename关键字"><a href="#typename关键字" class="headerlink" title="typename关键字"></a>typename关键字</h4><p>关键字 typename 在 C++标准化过程中被引入进来，用来澄清模板内部的一个标识符代表的 是某种类型，而不是数据成员<br>通常而言，当一个依赖于模板参数的名称代表的是某种类型的时候，就必须使用 typename。</p>
<p>使用 typename 的一种场景是用来声明泛型代码中标准容器的迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// print elements of an STL container template&lt;typename T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printcoll</span> <span class="params">(T <span class="keyword">const</span>&amp; coll)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::const_iterator pos; <span class="comment">// iterator to iterate over coll </span></span><br><span class="line">    <span class="function"><span class="keyword">typename</span> T::const_iterator <span class="title">end</span><span class="params">(coll.end())</span></span>; <span class="comment">// end position</span></span><br><span class="line">    <span class="keyword">for</span> (pos=coll.begin(); pos!=end; ++pos) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*pos&lt;&lt;’’;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ’\n’; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数模板中，调用参数是一个类型为 T 的标准容器。为了遍历容器中的所有元素，使 用了声明于每个标准容器中的迭代器类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stlcontainer</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = ...; <span class="comment">// iterator for read/write access </span></span><br><span class="line">    <span class="keyword">using</span> const_iterator = ...; <span class="comment">// iterator for read access ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因此为了使用模板类型 T 的 cons_iterator，必须在其前面使用 typename:</p>
<h4 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h4><p>对于基础类型，比如 int，double 以及指针类型，由于它们没有默认构造函数，因此它们不 会被默认初始化成一个有意义的值。比如任何未被初始化的局部变量的值都是未定义的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// x has undefined value</span></span><br><span class="line">    <span class="keyword">int</span>* ptr; <span class="comment">// ptr points to anywhere (instead of nowhere) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此在定义模板时，如果想让一个模板类型的变量被初始化成一个默认值，那么只是简单的 定义是不够的，因为对内置类型，它们不会被初始化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x; <span class="comment">// x has undefined value if T is built-in type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好显式的调用其默认构造函数来将它们初始化成 0(对于 bool 类型，初始化为 false，对于指针类型，初始化成 nullptr)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T x&#123;&#125;; <span class="comment">// x is zero (or false) if T is a built-in type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种初始化的方法被称为“值初始化(value initialization)”，它要么调用一个对象已有的 构造函数，要么就用零来初始化这个对象。即使它有显式的构造函数也是这样<br>在 C++11 之前，确保一个对象得到显示初始化的方式是:</p>
<blockquote>
<p>T x = T(); // x is zero (or false) if T is a built-in type</p>
</blockquote>
<p>为确保类模板中类型被参数化了的成员得到适当的初始化，可以定义一个默认的构造函数并 在其中对相应成员做初始化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        T x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MyClass() : x&#123;&#125; &#123; <span class="comment">// ensures that x is initialized even for</span></span><br><span class="line">        <span class="comment">//built-in types</span></span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用this-gt"><a href="#使用this-gt" class="headerlink" title="使用this-&gt;"></a>使用this-&gt;</h4><p>对于类模板，如果它的基类也是依赖于模板参数的，那么对它而言即使x是继承而来的，使用this-&gt;x和x也不一定是等效的。比如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            bar(); <span class="comment">// calls external bar() or error </span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Derived 中的 bar()永远不会被解析成Base中的bar()。因此这样做要么会遇到错误，要么就是调用了其它地方的bar()(比如可能是定义在其它地方的global的bar())，目前作为经验法则，建议当使用定义于基类中的、依赖于模板参数的成员时，用this-&gt;或者 Base<T>::来修饰它</p>
<h4 id="使用裸数组或者字符串常量的模板"><a href="#使用裸数组或者字符串常量的模板" class="headerlink" title="使用裸数组或者字符串常量的模板"></a>使用裸数组或者字符串常量的模板</h4><p>需要格外注意以下内容:<br>第一，如果参数是按引用传递的，那么参数类型不会退化(decay)。也就是说当传递”hello” 作为参数时，模板类型会被推断为 char const[6]。这样当向模板传递长度不同的裸数组或者 字符串常量时就可能遇到问题，因为它们对应的模板类型不一样。只有当按值传递参数时， 模板类型才会退化(decay)，这样字符串常量会被推断为 char const* 。<br>不过也可以像下面这样定义专门用来处理裸数组或者字符串常量的模板:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N, <span class="keyword">int</span> M&gt; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less</span> <span class="params">(T(&amp;a)[N], T(&amp;b)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;N &amp;&amp; i&lt;M; ++i)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&lt;a[i]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N &lt; M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当像下面这样使用该模板的时候:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; less(x,y) &lt;&lt; ’\n’;</span><br></pre></td></tr></table></figure>
<p>less&lt;&gt;中的 T 会被实例化成 int，N 被实例化成 3，M 被实例化成 5。</p>
<p>请注意你可以、某些情况下可能也必须去为边界未知的数组做重载或者部分特化。下面的代 码展示了对数组所做的所有可能的重载:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>;</span> <span class="comment">// 主模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> SZ&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T[SZ]&gt; // <span class="title">partial</span> <span class="title">specialization</span> <span class="title">for</span> <span class="title">arrays</span> <span class="title">of</span> <span class="title">known</span> <span class="title">bounds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"print() for T["</span> &lt;&lt; SZ &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> SZ&gt;</span><br><span class="line">structMyClass&lt;T(&amp;)[SZ]&gt; <span class="comment">//partialspec.forreferencestoarraysof known bounds</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"print() for T(&amp;)["</span> &lt;&lt; SZ &lt;&lt;<span class="string">"]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T[]&gt; // <span class="title">partial</span> <span class="title">specialization</span> <span class="title">for</span> <span class="title">arrays</span> <span class="title">of</span> <span class="title">unknown</span> <span class="title">bounds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"print()forT[]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T(&amp;)[]&gt; // <span class="title">partial</span> <span class="title">spec</span>. <span class="title">for</span> <span class="title">references</span> <span class="title">to</span> <span class="title">arrays</span> <span class="title">of</span> <span class="title">unknown</span> <span class="title">bounds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"print()forT(&amp;)[]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span>&lt;T*&gt; // <span class="title">partial</span> <span class="title">specialization</span> <span class="title">for</span> <span class="title">pointers</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"print()forT*\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码针对以下类型对 MyClass&lt;&gt;做了特化:边界已知和未知的数组，边界已知和未知 的数组的引用，以及指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"arrays.hpp"</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a1[<span class="number">7</span>], <span class="keyword">int</span> a2[], <span class="comment">// pointers by language rules</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> (&amp;a3)[<span class="number">42</span>], <span class="comment">// reference to array of known bound </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> (&amp;x0)[], <span class="comment">// reference to array of unknown bound </span></span></span></span><br><span class="line"><span class="function"><span class="params">    T1 x1, <span class="comment">// passing by value decays</span></span></span></span><br><span class="line"><span class="function"><span class="params">    T2&amp; x2, T3&amp;&amp; x3)</span> <span class="comment">// passing by reference &#123;</span></span></span><br><span class="line"><span class="function">        MyClass&lt;<span class="title">decltype</span><span class="params">(a1)</span>&gt;::<span class="title">print</span><span class="params">()</span></span>; <span class="comment">// uses MyClass&lt;T*&gt;</span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(a2)&gt;::print(); <span class="comment">// uses MyClass&lt;T*&gt; a1, a2 退化成 指针 因为语言特性</span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(a3)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[SZ]&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x0)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x1)&gt;::print(); <span class="comment">// uses MyClass&lt;T*&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x2)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt; </span></span><br><span class="line">        MyClass&lt;<span class="keyword">decltype</span>(x3)&gt;::print(); <span class="comment">// uses MyClass&lt;T(&amp;)[]&gt; // 万能引用，引用折叠</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">42</span>];</span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(a)&gt;::print(); <span class="comment">// uses MyClass&lt;T[SZ]&gt; </span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> x[]; <span class="comment">// forward declare array </span></span><br><span class="line">    MyClass&lt;<span class="keyword">decltype</span>(x)&gt;::print(); <span class="comment">// uses MyClass&lt;T[]&gt; </span></span><br><span class="line">    foo(a, a, a, x, x, x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">15</span>&#125;; <span class="comment">// define forward-declared array</span></span><br></pre></td></tr></table></figure>

<h4 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h4><p>通常只有当两个 stack 类型相同的时候才可以相互赋值(stack 的类型相同说明它们的元素类型也相同)。即使两个 stack 的元素类型之间可以隐式转换， 也不能相互赋值:<br>默认的赋值运算符要求等号两边的对象类型必须相同，因此如果两个 stack 之间的元素类型 不同的话，这一条件将得不到满足。<br>但是，只要将赋值运算符定义成模板，就可以将两个元素类型可以做转换的 stack 相互赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp;); &#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码中有如下两点改动:</p>
<ol>
<li>赋值运算符的参数是一个元素类型为 T2 的 stack。</li>
<li>新的模板使用 std::deque&lt;&gt;作为内部容器。这是为了方便新的赋值运算符的定义。</li>
</ol>
<p>新的赋值运算符被定义成下面这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp; op2) </span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;T2&gt; tmp(op2); <span class="comment">// create a copy of the assigned stack </span></span><br><span class="line">    elems.clear(); <span class="comment">// remove existing elements</span></span><br><span class="line">    <span class="keyword">while</span> (!tmp.empty()) &#123; <span class="comment">// copy all elements</span></span><br><span class="line">        elems.push_front(tmp.top());</span><br><span class="line">        tmp.pop();</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面实现多了一次拷贝，可以用另一种实现方式，为了访问 op2 的私有成员，可以将其它所有类型的 stack 模板的实例都定义成友元：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Void <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">        <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// assign stack of elements of type T2</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">        Stack&amp; <span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp;);</span><br><span class="line">        <span class="comment">// to get access to private members of Stack&lt;T2&gt; for any type T2:</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如你所见，由于模板参数的名字不会被用到，因此可以被省略掉:</p>
<blockquote>
<p>template<typename> friend class Stack;</p>
</blockquote>
<p>这样就就可以将赋值运算符定义成如下形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">Stack&lt;T&gt;&amp; Stack&lt;T&gt;::<span class="keyword">operator</span>= (Stack&lt;T2&gt; <span class="keyword">const</span>&amp; op2) </span><br><span class="line">&#123;</span><br><span class="line">    elems.clear(); <span class="comment">// remove existing elements </span></span><br><span class="line">    elems.insert(elems.begin(), <span class="comment">// insert at the beginning </span></span><br><span class="line">        op2.elems.begin(), <span class="comment">// all elements from op2 </span></span><br><span class="line">        op2.elems.end());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的赋值就不会改变 floatStack 的类型，也不会改变它的元素的类型。在赋值之后， floatStack 存储的元素依然是 float 类型，top()返回的值也依然是 float 类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">int</span>&gt; intStack; <span class="comment">// stack for ints</span></span><br><span class="line">Stack&lt;<span class="keyword">float</span>&gt; floatStack; <span class="comment">// stack for floats</span></span><br><span class="line">...</span><br><span class="line">floatStack = intStack; <span class="comment">// OK: stacks have different types, </span></span><br><span class="line"><span class="comment">// but int converts to float</span></span><br></pre></td></tr></table></figure>
<p>看上去这个赋值运算符模板不会进行类型检查，必要的类型检查会在将源 stack(上文中的 op2 或者其备 份 temp)中的元素插入到目标 stack 中的时候进行:</p>
<blockquote>
<p>elems.push_front(tmp.top());</p>
</blockquote>
<p>比如如果将存储 string 的 stack 赋值给存储 int 的 stack，那么在编译这一行代码的时候会遇 到如下错误信息:不能将通过 tmp.top()返回的 string 用作 elems.push_front()的参数。</p>
<h5 id="成员模板的特例化"><a href="#成员模板的特例化" class="headerlink" title="成员模板的特例化"></a>成员模板的特例化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoolString</span> &#123;</span> </span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> value; </span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        BoolString (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span><br><span class="line">        : value(s) &#123;&#125;</span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">        T get() <span class="keyword">const</span> &#123; <span class="comment">// get value (converted to T)</span></span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以像下面这样对其成员函数模板 get()进行全特例化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// full specialization for BoolString::getValue&lt;&gt;() for bool template&lt;&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> BoolString::get&lt;<span class="keyword">bool</span>&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="string">"true"</span> || value == <span class="string">"1"</span> || value == <span class="string">"on"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以像下面这样使用这个 class 以及它的全特例化版本:</p>
<blockquote>
<p>std::cout &lt;&lt; std::boolalpha;<br>BoolString s1(“hello”);<br>std::cout &lt;&lt; s1.get() &lt;&lt; ’\n’; //prints hello std::cout &lt;&lt; s1.get<bool>() &lt;&lt; ’\n’; //prints false BoolString s2(“on”);<br>std::cout &lt;&lt; s2.get<bool>() &lt;&lt; ’\n’; //prints true</p>
</blockquote>
<h5 id="泛型-lambdas-和成员模板"><a href="#泛型-lambdas-和成员模板" class="headerlink" title="泛型 lambdas 和成员模板"></a>泛型 lambdas 和成员模板</h5><p>在 C++14 中引入的泛型 lambdas，是一种成员模板的简化。对于一个简单的计算两个任意类 型参数之和的 lambda:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会默认为它构造下面这样一个类:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCompilerSpecificName</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SomeCompilerSpecificName(); <span class="comment">// constructor only callable by compiler</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T1 x, T2 y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="模板参数模板"><a href="#模板参数模板" class="headerlink" title="模板参数模板"></a>模板参数模板</h5><p>如果允许模板参数也是一个类模板的话，会有不少好处。在这里依然使用 Stack 类模板作为例子</p>
<p>对 5.5 节中的 stack 模板，如果不想使用默认的内部容器类型 std::deque，那么就需要两次指 定 stack 元素的类型。也就是说为了指定内部容器的类型，必须同时指出容器的类型和元素 的类型:</p>
<blockquote>
<p>Stack&lt;int, std::vector<int>&gt; vStack; // integer stack that uses a vector</p>
</blockquote>
<p>使用模板参数模板，在声明 Stack 类模板的时候就可以只指定容器的类型而不去指定容器中 元素的类型:</p>
<blockquote>
<p>Stack&lt;int, std::vector&gt; vStack; // integer stack that uses a vector</p>
</blockquote>
<p>为此就需要在 Stack 的定义中将第二个模板参数声明为模板参数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="class"><span class="keyword">class</span> <span class="title">Cont</span> = <span class="title">std</span>:</span>:<span class="built_in">deque</span>&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                Cont&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element</span></span><br><span class="line">                <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line">                <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">                    <span class="keyword">return</span> elems.empty(); </span><br><span class="line">                &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>区别在于第二个模板参数被定义为一个类模板:</p>
<blockquote>
<p>template<typename Elem> class Cont</p>
</blockquote>
<p>默认类型也从 std::deque<T>变成 std::deque，用第一个模板参数实例化第二个模板参数的情况是由 Stack 自身的情况决定的。实际上，可以在类模板内部用任意类型实例化一个模板参数模板。</p>
<p>从 C++11 开始，也可以用别名模板(alias template)取代 Cont，但是直到 C++17，在声明模 板参数模板时才可以用 typename 代替 class，我是觉得用typename比较好</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem&gt; <span class="keyword">typename</span> Cont = <span class="built_in">std</span>::<span class="built_in">deque</span>&gt;</span><br><span class="line">class Stack &#123; <span class="comment">//ERROR before C++17</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="模板参数模板的参数匹配"><a href="#模板参数模板的参数匹配" class="headerlink" title="模板参数模板的参数匹配"></a>模板参数模板的参数匹配</h5><p>如果你尝试使用新版本的 Stack，可能会遇到错误说默认的 std::deque 和模板参数模板 Cont 不匹配。这是因为在 C++17 之前，template<typename Elem> typename Cont = std::deque 中 的模板参数必须和实际参数(std::deque)的模板参数匹配(对变参模板有些例外，见 12.3.4 节)。而且实际参数(std::deque 有两个参数，第二个是默认参数 allocator)的默认参数也 要被匹配，这样 template<typename Elem> typename Cont = std::dequ 就不满足以上要求(不 过对 C++17 可以)</p>
<p>作为变通，可以将类模板定义成下面这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem,</span><br><span class="line">        <span class="keyword">typename</span> Alloc = <span class="built_in">std</span>::allocator&lt;Elem&gt;&gt; class Cont = <span class="built_in">std</span>::<span class="built_in">deque</span>&gt; </span><br><span class="line">class Stack &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Cont&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>为了使用依赖于模板参数的类型名称，需要用typename修饰该名称。</p>
</blockquote>
<blockquote>
<p>为了访问依赖于模板参数的父类中的成员，需要用this-&gt;或者类名修饰该成员。</p>
</blockquote>
<blockquote>
<p>嵌套类或者成员函数也可以是模板。一种应用场景是实现可以进行内部类型转换的泛型<br>代码。</p>
</blockquote>
<blockquote>
<p>模板化的构造函数或者赋值运算符不会取代预定义的构造函数和赋值运算符。</p>
</blockquote>
<blockquote>
<p>使用花括号初始化或者显式地调用默认构造函数，可以保证变量或者成员模板即使被内置类型实例化，也可以被初始化成默认值。</p>
</blockquote>
<blockquote>
<p>可以为裸数组提供专门的特化模板，它也可以被用于字符串常量。</p>
</blockquote>
<blockquote>
<p>只有在裸数组和字符串常量不是被按引用传递的时候，参数类型推断才会退化。(裸数组退化成指针)</p>
</blockquote>
<blockquote>
<p>可以定义变量模板(从C++14开始)。</p>
</blockquote>
<blockquote>
<p>模板参数也可以是类模板，称为模板参数模板(template template parameters)。</p>
</blockquote>
<blockquote>
<p>模板参数模板的参数类型必须得到严格匹配。</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2020/08/09/C++%20template%20Reading%20Note-Chapter6/" class="prev">PREV</a><a href="/2020/07/19/%E8%AF%BBgoogle-HDR-spaper/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://allen52.top">Steve</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>