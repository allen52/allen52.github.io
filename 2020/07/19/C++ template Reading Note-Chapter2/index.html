<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ template ReadingNote-Chapter2 · Steve's Blog</title><meta name="description" content="C++ template ReadingNote-Chapter2 - Steve"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://allen52.top/atom.xml" title="Steve's Blog"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Steve's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/3616621864" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/allen52" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ template ReadingNote-Chapter2</h1><div class="post-info">Jul 19, 2020</div><div class="post-content"><h1 id="第二章：类模板"><a href="#第二章：类模板" class="headerlink" title="第二章：类模板"></a>第二章：类模板</h1><h4 id="Stack类模板的实现"><a href="#Stack类模板的实现" class="headerlink" title="Stack类模板的实现"></a>Stack类模板的实现</h4><p>Stack类模板的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements </span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">	<span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">		<span class="comment">// return whether the stack is empty </span></span><br><span class="line">		<span class="keyword">return</span> elems.empty(); </span><br><span class="line">	&#125; </span><br><span class="line">    Stack (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    Stack$ <span class="keyword">operator</span>= (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">	<span class="keyword">void</span> Stack&lt;T&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">	elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop () &#123;</span><br><span class="line">	 assert(!elems.empty()); </span><br><span class="line">	 elems.pop_back(); </span><br><span class="line">	 <span class="comment">// remove last element </span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"> T <span class="keyword">const</span>&amp; Stack&lt;T&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line">	 assert(!elems.empty()); </span><br><span class="line">	 <span class="keyword">return</span> elems.back(); </span><br><span class="line">	 <span class="comment">// return copy of last element </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="声明一个类模板"><a href="#声明一个类模板" class="headerlink" title="声明一个类模板"></a>声明一个类模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements </span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">	<span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">		<span class="comment">// return whether the stack is empty </span></span><br><span class="line">		<span class="keyword">return</span> elems.empty(); </span><br><span class="line">	&#125; </span><br><span class="line">    Stack (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    Stack$ <span class="keyword">operator</span>= (Stack <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="comment">/**********************OR********************/</span></span><br><span class="line">    Stack (Stack&lt;T&gt; <span class="keyword">const</span>&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    Stack&lt;T&gt;&amp; <span class="keyword">operator</span>= (Stack&lt;T&gt; <span class="keyword">const</span>&amp;); <span class="comment">// assignment operator </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同于非模板类，不可以在函数内部或者块作用域内（{…}）声明和定义模板。通常 模板只能定义在 global/namespace 作用域</p>
<h5 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h5><p>定义类模板的成员函数时，必须指出它是一个模板，也必须使用该类模板的所有类型限制。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">	<span class="keyword">void</span> Stack&lt;T&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">	elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop () &#123;</span><br><span class="line">	 assert(!elems.empty()); </span><br><span class="line">	 elems.pop_back(); </span><br><span class="line">	 <span class="comment">// remove last element </span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"> T <span class="keyword">const</span>&amp; Stack&lt;T&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line">	 assert(!elems.empty()); </span><br><span class="line">	 <span class="keyword">return</span> elems.back(); </span><br><span class="line">	 <span class="comment">// return copy of last element </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Stack类模板的使用"><a href="#Stack类模板的使用" class="headerlink" title="Stack类模板的使用"></a>Stack类模板的使用</h5><p>通过声明 Stack<int>类型，在类模板内部 int 会被用作类型 T。被创建的 instStack 会使用一个 存储 int 的 vector 作为其 elems 成员，而且所有被用到的成员函数都会被用 int 实例化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt; <span class="keyword">int</span>&gt; intStack; <span class="comment">// stack of ints </span></span><br><span class="line">    Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; stringStack; <span class="comment">// stack of strings </span></span><br><span class="line">    <span class="comment">// manipulate int stack </span></span><br><span class="line">    intStack.push(<span class="number">7</span>); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; intStack.top() &lt;&lt; ’\n’; <span class="comment">// manipulate string stack </span></span><br><span class="line">    stringStack.push(<span class="string">"hello"</span>); </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stringStack.top() &lt;&lt; ’\n’;</span><br><span class="line">    stringStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，模板函数和模板成员函数只有在被调用的时候才会实例化<br>在这个例子中，对 int 和 std::string，默认构造函数，push()以及 top()函数都会被实例化, 。而 pop()只会针对 std::string 实例化</p>
<h5 id="部分地使用类模板"><a href="#部分地使用类模板" class="headerlink" title="部分地使用类模板"></a>部分地使用类模板</h5><p>一个类模板通常会对用来实例化它的类型进行多种操作（包含构造函数和析构函数）。这可 能会让你以为，要为模板参数提供所有被模板成员函数用到的操作.但是事实不是这样：模板参数只需要提供那些会被用到的操作（而不是可能会被用到的操作）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T <span class="keyword">const</span>&amp; elem : elems) &#123; </span><br><span class="line">            strm &lt;&lt; elem &lt;&lt; ’ ’; <span class="comment">// call &lt;&lt; for each element</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类依然可以用于那些没有提供 operator&lt;&lt;运算符的元素:只有在调用 printOn()的时候，才会导致错误</p>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>相比于通过 printOn()来打印 stack 的内容，更好的办法是去重载 stack 的 operator&lt;&lt;运算符。 而且和非模板类的情况一样，operator&lt;&lt;应该被实现为非成员函数，在其实现中可以调用 printOn()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    … </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOn</span><span class="params">()</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; strm)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    … </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp; strm, Stack&lt;T&gt; <span class="keyword">const</span>&amp; s) &#123;</span><br><span class="line">        s.printOn(strm); </span><br><span class="line">        <span class="keyword">return</span> strm; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然而如果你试着先声明一个友元函数，然后再去定义它，情况会变的很复杂。事实上我们有 两种选择：<br>先将 Stack<T>的 operator&lt;&lt;声明为一个模板，这要求先对 Stack<T>进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>;</span> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream&amp;, Stack&lt;T&gt; <span class="keyword">const</span>&amp;);</span><br></pre></td></tr></table></figure>
<p>接着就可以将这一模板声明为 Stack<T>的友元： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt; &lt;T&gt; (<span class="built_in">std</span>::ostream&amp;, Stack&lt;T&gt; </span><br><span class="line">    <span class="keyword">const</span>&amp;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模板类的特例化"><a href="#模板类的特例化" class="headerlink" title="模板类的特例化"></a>模板类的特例化</h4><p>为了特化一个类模板，在类模板声明的前面需要有一个 template&lt;&gt;，并且需要指明所希望特 化的类型。这些用于特化类模板的类型被用作模板参数，并且需要紧跟在类名的后面： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt; &#123;</span> </span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于被特化的模板，所有成员函数的定义都应该被定义成“常规”成员函数，也就是说所有 出现 T 的地方，都应该被替换成用于特化类模板的类型： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; elem) &#123; </span><br><span class="line">    elems.push_back(elem); </span><br><span class="line">    <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个用 std::string 实例化 Stack&lt;&gt;类模板的完整例子： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;std::string&gt; &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; elems; <span class="comment">// elements </span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>; <span class="comment">// push element </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::push (<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::pop () &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::top () <span class="keyword">const</span> &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="部分特例化"><a href="#部分特例化" class="headerlink" title="部分特例化"></a>部分特例化</h5><p>类模板可以只被部分的特例化。这样就可以为某些特殊情况提供特殊的实现，不过使用者还 是要定义一部分模板参数。比如，可以特殊化一个 Stack&lt;&gt;来专门处理指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack1.hpp"</span> </span></span><br><span class="line"><span class="comment">// partial specialization of class Stack&lt;&gt; for pointers: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;T*&gt; &#123;</span> </span><br><span class="line">    Private: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T*&gt; elems; <span class="comment">// elements </span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T*)</span></span>; <span class="comment">// push element </span></span><br><span class="line">        <span class="function">T* <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">        <span class="function">T* <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">            <span class="keyword">return</span> elems.empty();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T*&gt;::push (T* elem) &#123; </span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">T* Stack&lt;T*&gt;::pop () &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    T* p = elems.back(); </span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// and return it (unlike in the general case) </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">T* Stack&lt;T*&gt;::top () <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多模板参数的部分特例化"><a href="#多模板参数的部分特例化" class="headerlink" title="多模板参数的部分特例化"></a>多模板参数的部分特例化</h5><p>类模板也可以特例化多个模板参数之间的关系。比如对下面这个类模板： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进行如下这些特例化都是可以的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partial specialization: both template parameters have same type </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T,T&gt; &#123;</span> </span><br><span class="line">…</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// partial specialization: second type is int </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T,int&gt; &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// partial specialization: both template parameters are pointer types </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;T1*,T2*&gt; &#123;</span></span><br><span class="line">… </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="默认类模板参数"><a href="#默认类模板参数" class="headerlink" title="默认类模板参数"></a>默认类模板参数</h4><p>和函数模板一样，也可以给类模板的模板参数指定默认值。比如对 Stack&lt;&gt;，你可以将其用 来容纳元素的容器声明为第二个模板参数，并指定其默认值是 std::vector&lt;&gt;: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; </span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Cont elems; <span class="comment">// elements </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; elem)</span></span>; <span class="comment">// push element </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// pop element </span></span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// return top element </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// return whether the stack is empty</span></span><br><span class="line">    <span class="keyword">return</span> elems.empty(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt; </span><br><span class="line">    <span class="keyword">void</span> Stack&lt;T,Cont&gt;::push (T <span class="keyword">const</span>&amp; elem) &#123;</span><br><span class="line">    elems.push_back(elem); <span class="comment">// append copy of passed elem </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt; </span><br><span class="line"><span class="keyword">void</span> Stack&lt;T,Cont&gt;::pop () &#123; </span><br><span class="line">    assert(!elems.empty()); </span><br><span class="line">    elems.pop_back(); <span class="comment">// remove last element </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Cont&gt;</span><br><span class="line">T <span class="keyword">const</span>&amp; Stack&lt;T,Cont&gt;::top () <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(!elems.empty());</span><br><span class="line">    <span class="keyword">return</span> elems.back(); <span class="comment">// return copy of last element </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Stack&lt;&gt;模板可以像之前一样使用。如果只提供第一个模板参数作为元素类型，那么 vector 将被用来处理 Stack 中的元素：<br>而且在程序中，也可以为 Stack 指定一个容器类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack of doubles using a std::deque&lt;&gt; to manage the elements </span></span><br><span class="line">Stack&lt; <span class="keyword">double</span>,<span class="built_in">std</span>::<span class="built_in">deque</span>&lt; <span class="keyword">double</span>&gt;&gt; dblStack;</span><br></pre></td></tr></table></figure>

<h5 id="类别名"><a href="#类别名" class="headerlink" title="类别名"></a>类别名</h5><p>Typedefs 和 Alias 声明<br>1.使用关键字typedef:  <code>typedef Stack&lt;int&gt; IntStack; // typedef</code><br>2.使用关键字using:  <code>using IntStack = Stack &lt;int&gt;; // alias declaration</code></p>
<p>以上两种给一个已经存在的类型定义新名字的方式，被称为 type alias declaration。新的名字 被称为 type alias。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> DequeStack = Stack&lt;T, <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>DequeStack别名模板是被T参数化的</p>
<h5 id="类模板的类型推导"><a href="#类模板的类型推导" class="headerlink" title="类模板的类型推导"></a>类模板的类型推导</h5><p>直到 C++17，使用类模板时都必须<strong>显式指出所有的模板参数的类型</strong>（除非它们有默认值）。 从 C++17 开始，这一要求不在那么严格了。如果构造函数能够推断出所有模板参数的类型（对 那些没有默认值的模板参数），就不再需要显式的指明模板参数的类型。<br>比如可以定义 下面这样一个 Stack，它可以被一个元素初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; elems; <span class="comment">// elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Stack () = <span class="keyword">default</span>; </span><br><span class="line">        Stack (T <span class="keyword">const</span>&amp; elem) <span class="comment">// initialize stack with one element </span></span><br><span class="line">        : elems(&#123;elem&#125;) &#123; &#125;</span><br><span class="line">        …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后可以这样声明一个Stack：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack intStack = <span class="number">0</span>; <span class="comment">// Stack&lt;int&gt; deduced since C++17</span></span><br></pre></td></tr></table></figure>



</div></article></div></main><footer><div class="paginator"><a href="/2020/07/19/C++%20template%20Reading%20Note-Chapter3/" class="prev">PREV</a><a href="/2020/07/19/C++%20template%20Reading%20Note-Chapter1/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://allen52.top">Steve</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>