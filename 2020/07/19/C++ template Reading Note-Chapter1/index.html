<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ template ReadingNote-Chapter1 · Steve's Blog</title><meta name="description" content="C++ template ReadingNote-Chapter1 - Steve"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://allen52.top/atom.xml" title="Steve's Blog"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Steve's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/3616621864" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/allen52" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ template ReadingNote-Chapter1</h1><div class="post-info">Jul 19, 2020</div><div class="post-content"><h1 id="第一章：函数模板"><a href="#第一章：函数模板" class="headerlink" title="第一章：函数模板"></a>第一章：函数模板</h1><h4 id="两阶段编译检查-Two-Phase-Translation"><a href="#两阶段编译检查-Two-Phase-Translation" class="headerlink" title="两阶段编译检查 (Two-Phase Translation)"></a>两阶段编译检查 (Two-Phase Translation)</h4><p><strong>1.定义阶段:</strong> 模板的检查并不包含类型参数的检查</p>
<blockquote>
<p>语法检查。比如少了分号<br>使用了未定义的不依赖于模板参数的名称（类型名，函数名，……）。<br>未使用模板参数的 staticassertions</p>
</blockquote>
<p><strong>2.模板实例化阶段:</strong>  确保所有代码都是有效的，模板会再次被检查，尤其是那些依赖于类型参数的部分</p>
<h4 id="类型推断中的类型转换"><a href="#类型推断中的类型转换" class="headerlink" title="类型推断中的类型转换"></a>类型推断中的类型转换</h4><p>在类型推断的时候自动的类型转换是受限制的：</p>
<blockquote>
<p>参数是按引用传递的，任何类型转换都不被允许。通过模板类型参数 T 定义的 两个参数，它们实参的类型必须完全一样。</p>
</blockquote>
<p>调用参数是按值传递的，那么只有退化（decay）这一类简单转换是被允许的： const 和 volatile 限制符会被忽略，引用被转换成被引用的类型，rawarray 和函数被转换为相 应的指针类型。通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样。</p>
<p>但是像下面这样是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR: 不确定T该被推断为int还是double</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">foo(<span class="string">"hello"</span>, s); <span class="comment">//ERROR: 不确定T该被推断为 const[6] 还是 std::string</span></span><br></pre></td></tr></table></figure>
<p>解决方法：强制转换，指定类型，多个模板参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>), <span class="number">7.2</span>); <span class="comment">// OK</span></span><br><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// OK</span></span><br><span class="line">指明调用参数可能有不同的类型（多个模板参数）。</span><br></pre></td></tr></table></figure>

<h4 id="对默认调用参数的类型推断"><a href="#对默认调用参数的类型推断" class="headerlink" title="对默认调用参数的类型推断"></a>对默认调用参数的类型推断</h4><p>类型推断并不适用于默认调用参数。例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T = <span class="string">""</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// ERROR: 无法推断T的类型</span></span><br></pre></td></tr></table></figure>
<p>为应对这一情况，你需要给模板类型参数也声明一个默认参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="built_in">std</span>::<span class="built_in">string</span>&gt; </span><br><span class="line">viod foo(T = <span class="string">""</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"foo called"</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译的时候需要加上：<br>g++ -std=c++11 main.cpp -o test</p>
<h4 id="多个模板参数"><a href="#多个模板参数" class="headerlink" title="多个模板参数"></a>多个模板参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function">T1 <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以接受两个不同类型的调用参数。但是如示例代码所示，这也导致了 一个问题。如果你使用其中一个类型参数的类型作为返回类型，不管是不是和调用者预期地 一样，当应该返回另一个类型的值的时候，返回值会被做类型转换</p>
<p>C++提供了多种应对这一问题的方法：</p>
<blockquote>
<p>引入第三个模板参数作为返回类型。<br>让编译器找出返回类型。<br>将返回类型定义为两个参数类型的公共类型</p>
</blockquote>
<h5 id="作为返回类型的模板参数"><a href="#作为返回类型的模板参数" class="headerlink" title="作为返回类型的模板参数"></a>作为返回类型的模板参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">::max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>);</span><br></pre></td></tr></table></figure>
<p>调用 max<double>时，显式的指明了 RT 的类型是 double</p>
<h5 id="返回类型推断"><a href="#返回类型推断" class="headerlink" title="返回类型推断"></a>返回类型推断</h5><p>推断返回类型最简单也是最好的办法就是让编译器 来做这件事</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不使用 尾 置 返 回 类 型 （ trailingreturntype ） 的 情 况 下 将 auto 用于返回类型，要求 <strong>返回类型必须能够通过函数体中的返回语句推断出来</strong>。</p>
<p>在 C++11 中，尾置返回类型（trailingreturntype）允许我们使用函数的调用参数。 也就是说，我们可以基于运算符?:的结果声明返回类型： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line">auto max (T1 a, T2 b) -&gt; decltype(true?a:b);</span><br></pre></td></tr></table></figure>

<p>由于 T 可能是引用类型，返回类型就也可能被推断 为引用类型。因此你应该返回的是 decay 后的 T，像下面这样： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">auto max (T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true? a:b)&gt;::type &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们用到了类型萃取 <strong>（typetrait）std::decay&lt;&gt;</strong> ，它返回其 type 成员作为目标类型， 定义在标准库<type_trait>中（参见 D.5）。由于其 type 成员是一个类型，为了获取其结果， 需要用关键字 typename 修饰这个表达式。</p>
<h5 id="将返回类型声明为（common-type）"><a href="#将返回类型声明为（common-type）" class="headerlink" title="将返回类型声明为（common type）"></a>将返回类型声明为（common type）</h5><p>从 C++11 开始，标准库提供了一种指定“更一般类型”的方式。std::common_type&lt;&gt;::type 产生的类型是他的两个模板参数的公共类型。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">std::common_type_t&lt;T1,T2&gt; max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h4><p>可以给模板参数指定默认值。这些默认值被称为默认模板参数并且可以用于任意类型的 模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT =</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(<span class="literal">true</span> ? T1() : T2())&gt;&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用类型萃取 common_type作为返回类型的默认值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT = <span class="built_in">std</span>::<span class="keyword">common_type_t</span>&lt;T1,T2&gt;&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了显式指出返回类型，我们必须显式的指出全部三个 模板参数的类型。因此我们希望能够将返回类型作为第一个模板参数，并且依然能够从其它两个模板参数推断出它的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT = <span class="keyword">long</span>, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">RT max (T1 a, T2 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是只有当模板参数具有一个“天生的”默认值时，这才有意义。我们真正想要的是从前面 的模板参数推导出想要的默认值。</p>
<p>基于以上原因，最好也是最简单的办法是<strong>让编译器来推断出返回类型</strong></p>
<h4 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maximum of two int values:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b &lt; a ? a : b; &#125;</span><br><span class="line"><span class="comment">// maximum of two values of any type:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::max(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls the nontemplate for two ints</span></span><br><span class="line">    ::max(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">    ::max(’a’, ’b’); <span class="comment">//calls max&lt;char&gt; (by argument deduction)</span></span><br><span class="line">    ::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;int&gt; (by argumentdeduction)</span></span><br><span class="line">    ::max&lt;<span class="keyword">double</span>&gt;(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls max&lt;double&gt; (no argumentdeduction)</span></span><br><span class="line">    ::max(’a’, <span class="number">42.7</span>); <span class="comment">//calls the nontemplate for two ints</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非模板函数可以与其同名的函数模板共存，函数模板可以被实例化为与非模板函数具有相同的调用参数。模板解析过程优先选择非模板函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::max(<span class="number">7</span>, <span class="number">42</span>); <span class="comment">// calls the nontemplate for two ints</span></span><br></pre></td></tr></table></figure>
<p>如果模板可以实例化一个更匹配的函数，那么会选择这个模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::max(<span class="number">7.0</span>, <span class="number">42.0</span>); <span class="comment">// calls max&lt;double&gt; (by argument deduction)</span></span><br><span class="line">::max(’a’, ’b’); <span class="comment">//calls max&lt;char&gt; (by argument deduction)</span></span><br></pre></td></tr></table></figure>
<p>也可以显式指定一个空的模板列表，表明它会被解析成一个模板使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::max&lt;&gt;(<span class="number">7</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>模板参数推断时不允许自动类型转换，常规函数是允许的，因此最后一个调用会选择非模板函数</p>
<p>confused：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//像下面这样调用 max():</span></span><br><span class="line"><span class="keyword">auto</span> a = ::max(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// uses first template</span></span><br><span class="line"><span class="keyword">auto</span> b = ::max&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;(<span class="number">7.2</span>, <span class="number">4</span>); <span class="comment">// uses second template</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//error：</span></span><br><span class="line"><span class="keyword">auto</span> c = ::max&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>); <span class="comment">// ERROR: both function templates match</span></span><br></pre></td></tr></table></figure>
<p>两个模板都是匹配的，这会导致模板解析过程不知道该调用哪一个模板，从而导致未知错误，当重载函数模板的时候，你要保证对任意一个调用，都只会有一个模板匹配。</p>
<p>为指针和c字符串重载max()模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // maximum of two values of any type:</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of two pointers: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">max</span> <span class="params">(T* a, T* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *b &lt; *a ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of two C-strings: </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">max</span> <span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* a, <span class="keyword">char</span> <span class="keyword">const</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>; </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">42</span>; </span><br><span class="line">    <span class="keyword">auto</span> m1 = ::max(a,b); <span class="comment">// max() for two values of type int 【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"hey"</span>; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">"you"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m2 = ::max(s1,s2); <span class="comment">// max() for two values of type  std::string 【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* p1 = &amp;b; </span><br><span class="line">    <span class="keyword">int</span>* p2 = &amp;a; </span><br><span class="line">    <span class="keyword">auto</span> m3 = ::max(p1,p2); <span class="comment">// max() for two pointers【OK】</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* x = <span class="string">"hello"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* y = <span class="string">"world"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m4 = ::max(x,y); <span class="comment">// max() for two C-strings【OK】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常而言，在重载模板的时候，要尽可能少地做改动。你应该只是改变模板参数的个数或者显式的指定某些模板参数。 否则，可能会遇到意想不到的问题:<br>比如，如果你实现了一个按引用传递的 max()模板，然 后又重载了一个按值传递两个 C 字符串作为参数的模板，你不能用接受三个参数的模板来计 算三个 C 字符串的最大值： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type (call-by-reference) </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125; <span class="comment">// maximum of two C-strings (call-by-value) </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="title">max</span> <span class="params">(<span class="keyword">char</span> <span class="keyword">const</span>* a, <span class="keyword">char</span> <span class="keyword">const</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">strcmp</span>(b,a) &lt; <span class="number">0</span> ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// maximum of three values of any type (call-by-reference) </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b, T <span class="keyword">const</span>&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max (max(a,b), c); <span class="comment">//  【 error if max(a,b) uses call-by-value 】</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m1 = ::max(<span class="number">7</span>, <span class="number">42</span>, <span class="number">68</span>); <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s1 = <span class="string">"frederic"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s2 = <span class="string">"anica"</span>; </span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* s3 = <span class="string">"lucas"</span>; </span><br><span class="line">    <span class="keyword">auto</span> m2 = ::max(s1, s2, s3); <span class="comment">//run-time ERROR </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试了一下 gcc编译的时候好像可以检查出来：</p>
<blockquote>
<p>warning：returning reference to temporary</p>
</blockquote>
<p>需要确保函数模板在调用时，其已经在前面已经被定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="comment">// maximum of two values of any type: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max&lt;T&gt;() \n"</span>;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum of three values of any type: </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b, T c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> max (max(a,b), c); </span><br><span class="line">    <span class="comment">// uses the template version even for ints </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//because the following declaration comes </span></span><br><span class="line"><span class="comment">// too late: </span></span><br><span class="line"><span class="comment">// maximum of two int values: </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(int,int) \n"</span>; </span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    ::max(<span class="number">47</span>,<span class="number">11</span>,<span class="number">33</span>); <span class="comment">// OOPS: uses max&lt;T&gt;() instead of max(int,int) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后会出现：</p>
<blockquote>
<p>max<T>()<br>max<T>()</p>
</blockquote>
<p>调用的是上面的模板函数</p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="按值传递还是按引用"><a href="#按值传递还是按引用" class="headerlink" title="按值传递还是按引用"></a>按值传递还是按引用</h5><p><strong>问题一：</strong> 为什么我们声明的函数通常都是按值传递，而不是按引用传递。通常而 言，建议将按引用传递用于除简单类型（比如基础类型和 std::string_view）以外的类型，这 样可以免除不必要的拷贝成本</p>
<p>不过出于以下原因，按值传递通常更好一些： </p>
<blockquote>
<p>语法简单。<br>编译器能够更好地进行优化。<br>移动语义通常使拷贝成本比较低。<br>某些情况下可能没有拷贝或者移动。</p>
</blockquote>
<p>对于模板，还有一些特有情况：</p>
<blockquote>
<p>模板既可以用于简单类型，也可以用于复杂类型，因此如果默认选择适合于复杂类型可 能方式，可能会对简单类型产生不利影响</p>
</blockquote>
<p>虽然按值传递 stringliteral 和 rawarray 经常会遇到问题，但是按照引用传递它们通常只 会遇到更大的问题。第 7 章会对此做进一步讨论</p>
<p><strong>问题二：</strong>  为什么不适用 inline？</p>
<p>通常而言，函数模板不需要被声明成 inline。不同于非 inline 函数，我们可以把非 inline 的函 数模板定义在头文件里，然后在多个编译单元里 include 这个文件。</p>
<p>唯一一个例外是模板对某些类型的全特化，这时候最终的 code 不在是“泛型”的（所有的 模板参数都已被指定）。</p>
<p>严格从语言角度来看，inline只意味着在程序中函数的定义可以出现很多次，不过它也给 了编译器一个暗示，在调用该函数的地方函数应该被展开成 inline 的：这样做在某些情况下 可以提高效率，但是在另一些情况下也可能降低效率。现代编译器在没有关键字 inline 暗示 的情况下，通常也可以很好的决定是否将函数展开成 inline 的。</p>
<p><strong>问题三：</strong> 为什么不用constexpr<br>为了可以在编译阶段使用求最大值的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此你就可以在编译阶段的上下文中，实时地使用这个求最大值的函数模板： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[::max(<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="number">1000u</span>)];</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<blockquote>
<p>函数模板定义了一组适用于不同类型的函数。</p>
<p>当向模板函数传递变量时，函数模板会自行推断模板参数的类型，来决定去实例化出那 种类型的函数。</p>
<p>你也可以显式的指出模板参数的类型。 </p>
<p>你可以定义模板参数的默认值。</p>
<p>这个默认值可以使用该模板参数前面的模板参数的类 型，而且其后面的模板参数可以没有默认值。</p>
<p>函数模板可以被重载。</p>
<p>当定义新的函数模板来重载已有的函数模板时，必须要确保在任何调用情况下都只有一 个模板是最匹配的。</p>
<p>当你重载函数模板的时候，最好只是显式地指出了模板参数得了类型。</p>
<p>确保在调用某个函数模板之前，编译器已经看到了相对应的模板定义</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"></div><div class="copyright"><p>© 2019 - 2020 <a href="http://allen52.top">Steve</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>