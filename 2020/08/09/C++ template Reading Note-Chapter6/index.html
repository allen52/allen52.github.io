<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ template ReadingNote-Chapter6 · Steve's Blog</title><meta name="description" content="C++ template ReadingNote-Chapter6 - Steve"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://allen52.top/atom.xml" title="Steve's Blog"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Steve's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/3616621864" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/allen52" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ template ReadingNote-Chapter6</h1><div class="post-info">Aug 9, 2020</div><div class="post-content"><h1 id="移动语义和enable-if-lt-gt"><a href="#移动语义和enable-if-lt-gt" class="headerlink" title="移动语义和enable_if&lt;&gt;"></a>移动语义和enable_if&lt;&gt;</h1><p>移动语义(move semantics)是 C++11 引入的一个重要特性。在 copy 或者赋值的时候，可以 通过它将源对象中的内部资源 move(“steal”)到目标对象，而不是 copy 这些内容。当然 这样做的前提是源对象不在需要这些内部资源或者状态(因为源对象将会被丢弃)</p>
<p>关于移动语义的解释可以参考这篇文章：<a href="https://blog.csdn.net/p942005405/article/details/84644069" target="_blank" rel="noopener">https://blog.csdn.net/p942005405/article/details/84644069</a><br>实际std::move在做什么可以参考这篇文章：<a href="https://blog.csdn.net/iMatt/article/details/83834794" target="_blank" rel="noopener">https://blog.csdn.net/iMatt/article/details/83834794</a><br>而为什么要这么做，可以参考逼乎的回答：<a href="https://www.zhihu.com/question/50652989" target="_blank" rel="noopener">https://www.zhihu.com/question/50652989</a></p>
<p>移动语义对模板的设计有重要影响，在泛型代码中也引入了一些特殊的规则来支持移动语义</p>
<h4 id="完美转发-Perfect-Forwarding"><a href="#完美转发-Perfect-Forwarding" class="headerlink" title="完美转发(Perfect Forwarding)"></a>完美转发(Perfect Forwarding)</h4><p>假设希望实现的泛型代码可以将被传递参数的基本特性转发出去:</p>
<blockquote>
<p>可变对象被转发之后依然可变。<br>Const对象被转发之后依然是const的。<br>可移动对象(可以从中窃取资源的对象)被转发之后依然是可移动的。</p>
</blockquote>
<p>不使用模板的话，为达到这一目的就需要对以上三种情况分别编程。比如为了将调用 f()时 传递的参数转发给函数 g():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for variable\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X <span class="keyword">const</span>&amp;)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for constant\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;&amp;)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for move object\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X&amp; val)</span> </span>&#123;</span><br><span class="line">	g(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X <span class="keyword">const</span>&amp; val)</span> </span>&#123;</span><br><span class="line">	g(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">	g(<span class="built_in">std</span>::move(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	X v;</span><br><span class="line">	X <span class="keyword">const</span> c;</span><br><span class="line">	f(v);<span class="comment">// f() for nonconstant object calls f(X&amp;) =&gt; calls g(X&amp;)</span></span><br><span class="line">	f(c);<span class="comment">// f() for constant object calls f(X const&amp;) =&gt; calls g(X const&amp;)</span></span><br><span class="line">	f(X());<span class="comment">// f() for temporary calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;)</span></span><br><span class="line">	f(<span class="built_in">std</span>::move(v));<span class="comment">// f() for movable variable calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意其中针对可移动对象(一个右值引用)的代码不同于其它两组代码;它需要用 std::move() 来处理其参数，因为参数的移动语义不会被一起传递。</p>
<p>虽然第三个 f()中的 val 被声明成右值 引用，但是当其在 f()内部被使用时，它依然是一个非常量左值(参考附录 B)，其行为也将 和第一个 f()中的情况一样。因此如果不使用 std::move()的话，在第三个 f()中调用的将是 g(X&amp;) 而不是 g(X&amp;&amp;)。</p>
<p>如果试图在泛型代码中统一以上三种情况，会遇到这样一个问题:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    g(val); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模板只对前两种情况有效，对第三种用于可移动对象的情况无效.</p>
<p>基于这一原因，C++11 引入了特殊的规则对参数进行完美转发(perfect forwarding)。实现 这一目的的惯用方法如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    g(<span class="built_in">std</span>::forward&lt;T&gt;(val)); <span class="comment">// perfect forward val to g()     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 std::move 没有模板参数，并且会无条件地移动其参数;<br>而 std::forward&lt;&gt;会跟据被传递 参数的具体情况决定是否“转发”其潜在的移动语义。</p>
<p>不要以为模板参数 T 的 T&amp;&amp;和具体类型 X 的 X&amp;&amp;是一样的。虽然语法上看上去类似，但是 它们适用于不同的规则:</p>
<blockquote>
<p>具体类型X的X&amp;&amp;声明了一个右值引用参数。只能被绑定到一个可移动对象上(一个prvalue，比如临时对象，一个 xvalue，比如通过 std::move()传递的参数，更多细节参见附录 B)。它的值总是可变的，而且总是可以被“窃取”。</p>
<p>模板参数T的T&amp;&amp;声明了一个转发引用(亦称万能引用)。可以被绑定到可变、不可变(比如 const)或者可移动对象上。在函数内部这个参数也可以是可变、不可变或者 指向一个可以被窃取内部数据的值。</p>
</blockquote>
<p>一个可以完美转发其参数的程序会像下面这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for variable\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X <span class="keyword">const</span>&amp;)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for constant\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X&amp;&amp;)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g() for move object\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">	g(<span class="built_in">std</span>::forward&lt;T&gt;(val));<span class="comment">// call the right g() for any passed argument val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊成员函数模板"><a href="#特殊成员函数模板" class="headerlink" title="特殊成员函数模板"></a>特殊成员函数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// generic constructor for passed initial name:</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(STR&amp;&amp; n)</span> : <span class="title">name</span><span class="params">(<span class="built_in">std</span>::forward&lt;STR&gt;(n))</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"TMPL-CONSTR for ’"</span> &lt;&lt; name &lt;&lt; <span class="string">"’\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy and move constructor:</span></span><br><span class="line">    Person (Person <span class="keyword">const</span>&amp; p) : name(p.name) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"COPY-CONSTRPerson’"</span>&lt;&lt;name&lt;&lt;<span class="string">"’\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person (Person&amp;&amp; p) : name(<span class="built_in">std</span>::move(p.name)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MOVE-CONSTR Person ’"</span> &lt;&lt; name &lt;&lt; <span class="string">"’\n"</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当试图调用拷贝构造函数的时候，会遇到错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
<p>而用一个可移动对象初始化 Person 的话却可以正常工作:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="built_in">std</span>::move(p1))</span></span>; <span class="comment">// OK: move Person =&gt; calls MOVECONST</span></span><br></pre></td></tr></table></figure>

<p>根据 C++重载解析规则(参见 16.2.5 节)，对于一个非 const 左值的 Person p， 成员模板通常比预定义的拷贝构造函数更匹配:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt; </span><br><span class="line">Person(STR&amp;&amp; n)</span><br></pre></td></tr></table></figure>
<p>这里 STR 可以直接被替换成 Person&amp;，但是对拷贝构造函数还要做一步 const 转换。</p>
<p>额外提供一个非 const 的拷贝构造函数看上去是个不错的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person (Person&amp; p)</span><br></pre></td></tr></table></figure>

<p>不过这只是一个部分解决问题的方法，更好的办法依然是使用模板。我们真正想做的是当参 数是一个 Person 对象或者一个可以转换成 Person 对象的表达式时，不要启用模板。</p>
<p>这可以通过 std::enable_if&lt;&gt;实现，它也正是下一节要讲的内容。</p>
<h4 id="通过-std-enable-if-lt-gt-禁用模板"><a href="#通过-std-enable-if-lt-gt-禁用模板" class="headerlink" title="通过 std::enable_if&lt;&gt;禁用模板"></a>通过 std::enable_if&lt;&gt;禁用模板</h4><p>从 C++11 开始，通过 C++标准库提供的辅助模板 std::enable_if&lt;&gt;，可以在某些编译期条件下 忽略掉函数模板。</p>
<p>比如，如果函数模板 foo&lt;&gt;的定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;(<span class="keyword">sizeof</span>(T) &gt; <span class="number">4</span>)&gt;::type </span><br><span class="line">foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一模板定义会在 sizeof(T) &gt; 4 不成立的时候被忽略掉，如果 sizeof<T> &gt; 4 成立，函数模板 会展开成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::enable_if&lt;&gt;是一种类型萃取(type trait)，它会根据一个作为其(第一个)模 板参数的编译期表达式决定其行为:</p>
<blockquote>
<p>如果这个表达式结果为true，它的type成员会返回一个类型:<br>    – 如果没有第二个模板参数，返回类型是 void。<br>    – 否则，返回类型是其第二个参数的类型。</p>
<p>如果表达式结果 false，则其成员类型是未定义的。根据模板的一个叫做 SFINAE的规则， 这会导致包含 std::enable_if&lt;&gt;表达式的函数模板被忽略掉。</p>
</blockquote>
<p>由于将 enable_if 表达式放在声明的中间不是一个明智的做法，因此使用 std::enable_if&lt;&gt; 的更常见的方法是使用一个额外的、有默认值的模板参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;(<span class="keyword">sizeof</span>(T) &gt; <span class="number">4</span>)&gt;&gt; </span><br><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 sizeof(T) &gt; 4，它会被展开成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-enable-if-lt-gt"><a href="#使用-enable-if-lt-gt" class="headerlink" title="使用 enable_if&lt;&gt;"></a>使用 enable_if&lt;&gt;</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = </span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_convertible_v&lt;STR, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;&gt; </span><br><span class="line">Person(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure>
<p>如果 STR 可以转换成 std::string，这个定义会扩展成:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line">Person(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure>

<p>这里同样可以使用别名模板给限制条件定义一个别名:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString = </span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_convertible_v&lt;T,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt; </span><br><span class="line">Person(STR&amp;&amp; n);</span><br></pre></td></tr></table></figure>

<p>现在完整 Person 类如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EnableIfString = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_convertible&lt;T,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::value&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//generic constuctor for passed initial name:</span></span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR, <span class="keyword">typename</span> = EnableIfString&lt;STR&gt;&gt;</span><br><span class="line">		<span class="keyword">explicit</span> Person(STR&amp;&amp; n)</span><br><span class="line">		: name(<span class="built_in">std</span>::forward&lt;STR&gt;(n)) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"TMPL-CONSTR for "</span> &lt;&lt; name&lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//copy and move constructor:</span></span><br><span class="line">		Person (Person <span class="keyword">const</span>&amp; p) : name(p.name) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"COPY-CONSTR Person "</span> &lt;&lt;name&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Person(Person&amp;&amp; p) : name(<span class="built_in">std</span>::move(p.name)) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"MOVE-CONSTR Person "</span>&lt;&lt;name&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-concept-简化-enable-if-lt-gt-表达式"><a href="#使用-concept-简化-enable-if-lt-gt-表达式" class="headerlink" title="使用 concept 简化 enable_if&lt;&gt;表达式"></a>使用 concept 简化 enable_if&lt;&gt;表达式</h4><p>即使使用了模板别名，enable_if 的语法依然显得很蠢，因为它使用了一个变通方法:为了达 到目的，使用了一个额外的模板参数，并且通过“滥用”这个参数对模板的使用做了限制。 这样的代码不容易读懂，也使模板中剩余的代码不易理解。<br>原则上我们所需要的只是一个能够对函数施加限制的语言特性，当这一限制不被满足的时 候，函数会被忽略掉。</p>
<p>这个语言特性就是人们期盼已久的 concept，可以通过其简单的语法对函数模板施加限制条 件。不幸的是，虽然已经讨论了很久，但是 concept 依然没有被纳入 C++17 标准。一些编译 器目前对 concept 提供了试验性的支持，不过其很有可能在 C++17 之后的标准中得到支持(目 前确定将在 C++20 中得到支持)。</p>
<p>通过使用 concept 可以写出下面这样的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> STR&gt;</span><br><span class="line"><span class="keyword">requires</span> <span class="built_in">std</span>::is_convertible_v&lt;STR,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;</span><br><span class="line">Person(STR&amp;&amp; n) : name(<span class="built_in">std</span>::forward&lt;STR&gt;(n)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>在模板中，可以通过使用“转发引用”(亦称“万能引用”，声明方式为模板参数T 加&amp;&amp;)和 std::forward&lt;&gt;将模板调用参完美地数转发出去。</p>
<p>将完美转发用于成员函数模板时，在copy或者move对象的时候它们可能比预定义的 特殊成员函数更匹配。</p>
<p>可以通过使用std::enable_if&lt;&gt;并在其条件为false的时候禁用模板。</p>
<p>通过使用std::enable_if&lt;&gt;，可以避免一些由于构造函数模板或者赋值构造函数模板比隐<br>式产生的特殊构造函数更加匹配而带来的问题。</p>
<p>可以通过删除对 const volatile 类型参数预定义的特殊成员函数，并结合使用<br>std::enable_if&lt;&gt;，将特殊成员函数模板化。</p>
<p>通过concept可以使用更直观的语法对函数模板施加限制。</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2020/07/21/C++%20template%20Reading%20Note-Chapter5/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://allen52.top">Steve</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>